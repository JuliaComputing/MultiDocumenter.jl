<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/MultiDocumenter.jl/'</script><script charset="utf-8" src="../../../pagefind/pagefind.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/pagefind_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Internals · JuliaInterpreter.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://juliacomputing.github.io/MultiDocumenter.jl/debug/stable/internals/" rel="canonical"/><link href="../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../assets/default/pagefind.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../docs/">MultiDocumenter</a><div class="nav-dropdown"><button class="nav-item dropdown-label">Debugging</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../inf/">Infiltrator</a><a class="nav-link active nav-item" href="../../">JuliaInterpreter</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Mega Debugger</button><div class="nav-dropdown-container nav-mega-dropdown-container"><div class="nav-mega-column"><div class="column-header">Column 1</div><ul class="column-content"><a class="nav-link nav-item" href="../../../inf/">Infiltrator</a><a class="nav-link active nav-item" href="../../">JuliaInterpreter</a><a class="nav-link nav-item" href="https://github.com/avik-pal/Lux.jl" target="_blank">Lux</a></ul></div><div class="nav-mega-column"><div class="column-header">Column 2</div><ul class="column-content"><a class="nav-link nav-item" href="../../../inf/">Infiltrator</a><a class="nav-link active nav-item" href="../../">JuliaInterpreter</a></ul></div></div></div><a class="nav-link nav-item" href="../../../data/">DataSets</a><div class="search nav-item"><input id="search-input" placeholder="Search everywhere..."/><ol class="suggestions hidden" id="search-result-container"></ol><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><nav class="toc"><h1>JuliaInterpreter.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../ast/">Lowered representation</a></li><li class="current"><a class="toctext" href="">Internals</a><ul class="internal"><li><a class="toctext" href="#Basic-usage-1">Basic usage</a></li><li><a class="toctext" href="#More-complex-expressions-1">More complex expressions</a></li><li><a class="toctext" href="#Toplevel-code-and-world-age-1">Toplevel code and world age</a></li></ul></li><li><a class="toctext" href="../dev_reference/">Function reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="">Internals</a></li></ul><a class="edit-page" href="https://github.com/JuliaDebug/JuliaInterpreter.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Internals-1" id="Internals-1">Internals</a></h1><h2><a class="nav-anchor" href="#Basic-usage-1" id="Basic-usage-1">Basic usage</a></h2><p>The process of executing code in the interpreter is to prepare a <code>frame</code> and then evaluate these statements one-by-one, branching via the <code>goto</code> statements as appropriate. Using the <code>summer</code> example described in <a href="../ast/#Lowered-representation-1">Lowered representation</a>, let's build a frame:</p><pre><code class="language-julia">julia&gt; frame = JuliaInterpreter.enter_call(summer, A)
Frame for summer(A::AbstractArray{T,N} where N) where T in Main at REPL[2]:2
   1* 2  1 ─       s = (zero)($(Expr(:static_parameter, 1)))
   2  3  │   %2  = A
   3  3  │         #temp# = (iterate)(%2)
⋮
A = [1, 2, 5]
T = Int64</code></pre><p>This is a <a href="../dev_reference/#JuliaInterpreter.Frame"><code>Frame</code></a>. Only a portion of the <code>CodeInfo</code> is shown, a small region surrounding the current statement (marked with <code>*</code> or in yellow text). The full <code>CodeInfo</code> can be extracted as <code>code = frame.framecode.src</code>. (It's a slightly modified form of one returned by <code>@code_lowered</code>, in that it has been processed by <a href="../dev_reference/#JuliaInterpreter.optimize!"><code>JuliaInterpreter.optimize!</code></a> to speed up run-time execution.)</p><p><code>frame</code> has another field, <code>framedata</code>, that holds values needed for or generated by execution. The input arguments and local variables are in <code>locals</code>:</p><pre><code class="language-julia">julia&gt; frame.framedata.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 nothing
 nothing
 nothing</code></pre><p>These correspond to the <code>code.slotnames</code>; the first is the <code>#self#</code> argument and the second is the input array. The remaining local variables (e.g., <code>s</code> and <code>a</code>), have not yet been assigned–-we've only built the frame, but we haven't yet begun to execute it. The static parameter, <code>T</code>, is stored in <code>frame.framedata.sparams</code>:</p><pre><code class="language-julia">julia&gt; frame.framedata.sparams
1-element Array{Any,1}:
 Int64</code></pre><p>The <code>Expr(:static_parameter, 1)</code> statement refers to this value.</p><p>The other main storage is for the generated SSA values:</p><pre><code class="language-julia">julia&gt; frame.framedata.ssavalues
16-element Array{Any,1}:
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef</code></pre><p>Since we haven't executed any statements yet, these are all undefined.</p><p>The other main entity is the so-called <a href="https://en.wikipedia.org/wiki/Program_counter">program counter</a>, which just indicates the next statement to be executed:</p><pre><code class="language-julia">julia&gt; frame.pc
1</code></pre><p>Let's try executing the first statement:</p><pre><code class="language-julia">julia&gt; JuliaInterpreter.step_expr!(frame)
2</code></pre><p>This indicates that it ran statement 1 and is prepared to run statement 2. (It's worth noting that the first line included a <code>call</code> to <code>zero</code>, so behind the scenes JuliaInterpreter created a new frame for <code>zero</code>, executed all the statements, and then popped back to <code>frame</code>.) Since the first statement is an assignment of a local variable, let's check the locals again:</p><pre><code class="language-julia">julia&gt; frame.framedata.locals
5-element Array{Union{Nothing, Some{Any}},1}:
 Some(summer)
 Some([1, 2, 5])
 Some(0)
 nothing
 nothing</code></pre><p>You can see that the entry corresponding to <code>s</code> has been initialized.</p><p>The next statement just retrieves one of the slots (the input argument <code>A</code>) and stores it in an SSA value:</p><pre><code class="language-julia">julia&gt; JuliaInterpreter.step_expr!(frame)
3

julia&gt; frame.framedata.ssavalues
16-element Array{Any,1}:
 #undef
    [1, 2, 5]
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef
 #undef</code></pre><p>One can easily continue this until execution completes, which is indicated when <code>step_expr!</code> returns <code>nothing</code>. Alternatively, use the higher-level <code>JuliaInterpreter.finish!(frame)</code> to step through the entire frame, or <code>JuliaInterpreter.finish_and_return!(frame)</code> to also obtain the return value.</p><h2><a class="nav-anchor" href="#More-complex-expressions-1" id="More-complex-expressions-1">More complex expressions</a></h2><p>Sometimes you might have a whole sequence of expressions you want to run. In such cases, your first thought should be <code>prepare_thunk</code>. Here's a demonstration:</p><pre><code class="language-julia">using Test

ex = quote
    x, y = 1, 2
    @test x + y == 3
end

frame = JuliaInterpreter.prepare_thunk(Main, ex)
JuliaInterpreter.finish_and_return!(frame)

# output

Test Passed</code></pre><h2><a class="nav-anchor" href="#Toplevel-code-and-world-age-1" id="Toplevel-code-and-world-age-1">Toplevel code and world age</a></h2><p>Code that defines new <code>struct</code>s, new methods, or new modules is a bit more complicated and requires special handling. In such cases, calling <code>finish_and_return!</code> on a frame that defines these new objects and then calls them can trigger a <a href="https://docs.julialang.org/en/latest/manual/methods/#Redefining-Methods-1">world age error</a>, in which the method is considered to be too new to be run by the currently compiled code. While one can resolve this by using <code>Base.invokelatest</code>, we'd have to use that strategy throughout the entire package.  This would cause a major reduction in performance. To resolve this issue without leading to performance problems, care is required to return to "top level" after defining such objects. This leads to altered syntax for executing such expressions.</p><p>Here's a demonstration of the problem:</p><pre><code class="language-julia">ex = :(map(x-&gt;x^2, [1, 2, 3]))
frame = JuliaInterpreter.prepare_thunk(Main, ex)
julia&gt; JuliaInterpreter.finish_and_return!(frame)
ERROR: this frame needs to be run a top level</code></pre><p>The reason for this error becomes clearer if we examine <code>frame</code> or look directly at the lowered code:</p><pre><code class="language-julia">julia&gt; Meta.lower(Main, ex)
:($(Expr(:thunk, CodeInfo(
1 ─      $(Expr(:thunk, CodeInfo(
1 ─     global ##17#18
│       const ##17#18
│       $(Expr(:struct_type, Symbol("##17#18"), :((Core.svec)()), :((Core.svec)()), :(Core.Function), :((Core.svec)()), false, 0))
└──     return
)))
│   %2 = (Core.svec)(##17#18, Core.Any)
│   %3 = (Core.svec)()
│   %4 = (Core.svec)(%2, %3)
│        $(Expr(:method, false, :(%4), CodeInfo(quote
    (Core.apply_type)(Base.Val, 2)
    (%1)()
    (Base.literal_pow)(^, x, %2)
    return %3
end)))
│        #17 = %new(##17#18)
│   %7 = #17
│   %8 = (Base.vect)(1, 2, 3)
│   %9 = map(%7, %8)
└──      return %9
))))</code></pre><p>All of the code before the <code>%7</code> line is devoted to defining the anonymous function <code>x-&gt;x^2</code>: it creates a new "anonymous type" (here written as <code>##17#18</code>), and then defines a "call function" for this type, equivalent to <code>(##17#18)(x) = x^2</code>.</p><p>In some cases one can fix this simply by indicating that we want to run this frame at top level:</p><pre><code class="language-julia">julia&gt; JuliaInterpreter.finish_and_return!(frame, true)
3-element Array{Int64,1}:
 1
 4
 9</code></pre><p>Here's a more fine-grained look at what's happening under the hood (and a robust strategy for more complex situations where there may be nested calls of new methods):</p><pre><code class="language-julia">modexs, _ = JuliaInterpreter.split_expressions(Main, ex)
for (mod, e) in modexs
    frame = JuliaInterpreter.prepare_thunk(mod, e)
    while true
        JuliaInterpreter.through_methoddef_or_done!(frame) === nothing &amp;&amp; break
    end
    JuliaInterpreter.get_return(frame)
end</code></pre><p>This splits the expression into a sequence of frames (here just one, but more complex blocks may be split up into many). Then, each frame is executed until it finishes defining a new method, then returns to top level. The return to top level causes an update in the world age. If the frame hasn't been finished yet (if the return value wasn't <code>nothing</code>), this continues executing where it left off.</p><p>(Incidentally, <code>JuliaInterpreter.enter_call(map, x-&gt;x^2, [1, 2, 3])</code> works fine on its own, because the anonymous function is defined by the caller–-you'll see that the created frame is very simple.)</p><footer><hr/><a class="previous" href="../ast/"><span class="direction">Previous</span><span class="title">Lowered representation</span></a><a class="next" href="../dev_reference/"><span class="direction">Next</span><span class="title">Function reference</span></a></footer></article></body></HTML>