[{"id":3,"pagetitle":"Infiltrator.jl","title":"Infiltrator.jl","ref":"/inf/stable/#Infiltrator.jl","content":" Infiltrator.jl This packages provides the  @infiltrate  macro, which acts as a breakpoint with neglible runtime performance overhead. Note that you cannot access other function scopes or step into further calls. Use an actual debugger if you need that level of flexibility. Running code that ends up triggering the  @infiltrate  REPL mode via inline evaluation in VS Code or Juno can cause issues, so it's recommended to always use the REPL directly."},{"id":4,"pagetitle":"Infiltrator.jl","title":"@infiltrate","ref":"/inf/stable/#@infiltrate","content":" @infiltrate @infiltrate cond = true @infiltrate  sets an infiltration point. When the infiltration point is hit, it will drop you into an interactive REPL session that lets you inspect local variables and the call stack as well as execute aribtrary statements in the context of the current local and global scope. The optional argument  cond  only enables this infiltration point if it evaluates to  true . You can also use if isdefined(Main, :Infiltrator)\n  Main.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\nend to infiltrate package code without any post-hoc evaluation into the module (because the functional form does not require Infiltrator to be loaded at compiletime)."},{"id":5,"pagetitle":"Infiltrator.jl","title":"@exfiltrate","ref":"/inf/stable/#@exfiltrate","content":" @exfiltrate @exfiltrate Assigns all local variables into global storage."},{"id":6,"pagetitle":"Infiltrator.jl","title":"The safehouse","ref":"/inf/stable/#The-safehouse","content":" The safehouse Exfiltrating variables (with  @exfiltrate  or by assignment in an  @infiltrate  session) happens by assigning the variable to a global storage space (backed by a module); any exfiltrated objects can be directly accessed, via  Infiltrator.store  or its exported aliases  safehouse  or  exfiltrated : julia> foo(x) = @exfiltrate\nfoo (generic function with 1 method)\n\njulia> foo(3)\n\njulia> safehouse.x # or exfiltrated.x\n3 You can reset the safehouse with  Infiltrator.clear_store!() . You can also assign a specific module with  Infiltrator.set_store!(mod) . This allows you to e.g. set the backing module to  Main  and therefore export the contents of the safehouse to the global namespace (although doing so is not recommended)."},{"id":7,"pagetitle":"Infiltrator.jl","title":"Example usage","ref":"/inf/stable/#Example-usage","content":" Example usage julia> function f(x)\n         out = []\n         for i in x\n           push!(out, 2i)\n           @infiltrate\n         end\n         out\n       end\nf (generic function with 1 method)\n\njulia> f([1,2,3])\nInfiltrating f(x::Vector{Int64})\n  at REPL[10]:5\n\ninfil> ?\n  Code entered here is evaluated in the current scope. Changes to local variables are not possible; global variables can only be changed with eval/@eval.\n\n  All assignments will end up in the safehouse.\n\n  The following commands are special cased:\n\n    •  ?: Print this help text.\n\n    •  @trace: Print the current stack trace.\n\n    •  @locals: Print local variables. @locals x y only prints x and y.\n\n    •  @exfiltrate: Save all local variables into the store. @exfiltrate x y saves x and y; this variant can also exfiltrate variables defined in the infil> REPL.\n\n    •  @toggle: Toggle infiltrating at this @infiltrate spot (clear all with Infiltrator.clear_disabled!()).\n\n    •  @continue: Continue to the next infiltration point or exit (shortcut: Ctrl-D).\n\n    •  @doc symbol: Get help for symbol (same as in the normal Julia REPL).\n\n    •  @exit: Stop infiltrating for the remainder of this session and exit (on Julia versions prior to 1.5 this needs to be manually cleared with Infiltrator.end_session!()).\n\ninfil> @locals\n- out::Vector{Any} = Any[2]\n- i::Int64 = 1\n- x::Vector{Int64} = [1, 2, 3]\n\ninfil> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n [1] __throw_rational_argerror_zero(T::Type)\n   @ Base ./rational.jl:32\n [2] Rational{Int64}(num::Int64, den::Int64)\n   @ Base ./rational.jl:34\n [3] Rational\n   @ ./rational.jl:39 [inlined]\n [4] //(n::Int64, d::Int64)\n   @ Base ./rational.jl:62\n [5] top-level scope\n   @ none:1\n\ninfil> @toggle\nDisabled infiltration at this infiltration point.\n\ninfil> @toggle\nEnabled infiltration at this infiltration point.\n\ninfil> @continue\n\nInfiltrating f(x::Vector{Int64})\n  at REPL[10]:5\n\ninfil> intermediate = copy(out)\n2-element Vector{Any}:\n 2\n 4\n\ninfil> @exfiltrate intermediate x\nExfiltrating 2 local variables into the safehouse.\n\ninfil> @exit\n\n3-element Vector{Any}:\n 2\n 4\n 6\n\njulia> safehouse.intermediate\n2-element Vector{Any}:\n 2\n 4\n\njulia> @withstore begin\n         x = 23\n         x .* intermediate\n       end\n2-element Vector{Int64}:\n 46\n 92"},{"id":8,"pagetitle":"Infiltrator.jl","title":"Related projects","ref":"/inf/stable/#Related-projects","content":" Related projects @exfiltrate  for Python"},{"id":11,"pagetitle":"API","title":"API","ref":"/inf/stable/API/#API","content":" API"},{"id":12,"pagetitle":"API","title":"Infiltration and exfiltration","ref":"/inf/stable/API/#Infiltration-and-exfiltration","content":" Infiltration and exfiltration Add  @infiltrate  to any function to start the  infil>  REPL mode when that line runs. It's recommended to put Infiltrator.jl into your global environment and not into package environments for two reasons: Infiltrator.jl is intended as a development tool only and as such should not be shipped Any  @infiltrate  invocations in your package code will fail at compile-time, which prevents you from accidentally committing infiltrated code This means that you'll need to use  Revise.jl , inline evaluation in VS Code, or just plain old  @eval  to apply  @infiltrate  statements in your package code."},{"id":13,"pagetitle":"API","title":"Infiltrator.@infiltrate","ref":"/inf/stable/API/#Infiltrator.@infiltrate","content":" Infiltrator.@infiltrate  —  Macro @infiltrate cond = true @infiltrate  sets an infiltration point (or breakpoint). When the infiltration point is hit, it will drop you into an interactive REPL session that lets you inspect local variables and the call stack as well as execute aribtrary statements in the context of the current functions module. This macro also accepts an optional argument  cond  that must evaluate to a boolean, and then this macro will serve as a \"conditinal breakpoint\", which starts inspections only when its condition is  true . source"},{"id":14,"pagetitle":"API","title":"Infiltrator.infiltrate","ref":"/inf/stable/API/#Infiltrator.infiltrate","content":" Infiltrator.infiltrate  —  Function infiltrate(mod, locals, file, line) Function form of  @infiltrate . Use this to conditionally infiltrate package code without using e.g. Revise (because this version is valid during precompilation). This would typically be used as if isdefined(Main, :Infiltrator)\n  Main.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\nend source"},{"id":15,"pagetitle":"API","title":"Infiltrator.@exfiltrate","ref":"/inf/stable/API/#Infiltrator.@exfiltrate","content":" Infiltrator.@exfiltrate  —  Macro @exfiltrate Assigns all local variables into the global storage. source"},{"id":16,"pagetitle":"API","title":"The safehouse","ref":"/inf/stable/API/#The-safehouse","content":" The safehouse This is where all exfiltrated variables end up. You can either exfiltrate a variable explicitly with  @exfiltrate  or implicitly by assignment in the  infil>  REPL mode."},{"id":17,"pagetitle":"API","title":"Infiltrator.safehouse","ref":"/inf/stable/API/#Infiltrator.safehouse","content":" Infiltrator.safehouse  —  Constant safehouse\nexfiltrated\nInfiltrator.store Global storage for storing values while  @infiltrate ing or  @exfiltrate ing. Also see  clear_store! ,  set_store! , and  @withstore  for safehouse-related functionality. source"},{"id":18,"pagetitle":"API","title":"Infiltrator.clear_store!","ref":"/inf/stable/API/#Infiltrator.clear_store!","content":" Infiltrator.clear_store!  —  Function clear_store!(s = safehouse) Reset the store used for global symbols. source"},{"id":19,"pagetitle":"API","title":"Infiltrator.set_store!","ref":"/inf/stable/API/#Infiltrator.set_store!","content":" Infiltrator.set_store!  —  Function set_store!(s = safehouse, m::Module) Set the module backing the store  s . source"},{"id":20,"pagetitle":"API","title":"Infiltrator.@withstore","ref":"/inf/stable/API/#Infiltrator.@withstore","content":" Infiltrator.@withstore  —  Macro @withstore ex Evaluates the expression  ex  in the context of the global store. Mainly intended for interactive use, as changes to the store's state will not propagate into the returned expression. source"},{"id":21,"pagetitle":"API","title":"Utility","ref":"/inf/stable/API/#Utility","content":" Utility"},{"id":22,"pagetitle":"API","title":"Infiltrator.clear_disabled!","ref":"/inf/stable/API/#Infiltrator.clear_disabled!","content":" Infiltrator.clear_disabled!  —  Function clear_disabled!(s = safehouse) Clear all disabled infiltration points. source"},{"id":23,"pagetitle":"API","title":"Infiltrator.end_session!","ref":"/inf/stable/API/#Infiltrator.end_session!","content":" Infiltrator.end_session!  —  Function end_session!(s = safehouse) End this infiltration session (reverts the effect of  @exit  in the  debug>  REPL). Only needs to be manually called on Julia versions prior to 1.5. source"},{"id":24,"pagetitle":"API","title":"Infiltrator.toggle_async_check","ref":"/inf/stable/API/#Infiltrator.toggle_async_check","content":" Infiltrator.toggle_async_check  —  Function toggle_async_check(enabled) Enable or disable the check for safe REPL mode switching. May result in a non-functional REPL. source"},{"id":29,"pagetitle":"Home","title":"JuliaInterpreter","ref":"/debug/stable/#JuliaInterpreter","content":" JuliaInterpreter This package implements an  interpreter  for Julia code. Normally, Julia compiles your code when you first execute it; using JuliaInterpreter you can avoid compilation and execute the expressions that define your code directly. Interpreters have a number of applications, including support for stepping debuggers."},{"id":30,"pagetitle":"Home","title":"Use as an interpreter","ref":"/debug/stable/#Use-as-an-interpreter","content":" Use as an interpreter Using this package as an interpreter is straightforward: julia> using JuliaInterpreter\n\njulia> list = [1, 2, 5]\n3-element Vector{Int64}:\n 1\n 2\n 5\n\njulia> sum(list)\n8\n\njulia> @interpret sum(list)\n8"},{"id":31,"pagetitle":"Home","title":"Breakpoints","ref":"/debug/stable/#Breakpoints","content":" Breakpoints You can interrupt execution by setting breakpoints. You can set breakpoints via packages that explicitly target debugging, like  Juno ,  Debugger , and  Rebugger . But all of these just leverage the core functionality defined in JuliaInterpreter, so here we'll illustrate it without using any of these other packages. Let's set a conditional breakpoint, to be triggered any time one of the elements in the argument to  sum  is bigger than 4: julia> bp = @breakpoint sum([1, 2]) any(x->x>4, a); Note that in writing the condition, we used  a , the name of the argument to the relevant method of  sum . Conditionals should be written using a combination of argument and parameter names of the method into which you're inserting a breakpoint; you can also use any globally-available name (as used here with the  any  function). Now let's see what happens: julia> @interpret sum([1,2,3])  # no element bigger than 4, breakpoint should not trigger\n6\n\njulia> frame, bpref = @interpret sum([1,2,5])  # should trigger breakpoint\n(Frame for sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873\nc 1* 873  1 ─      nothing\n  2  873  │   %2 = ($(QuoteNode(NamedTuple)))()\n  3  873  │   %3 = Base.pairs(%2)\n⋮\na = [1, 2, 5], breakpoint(sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873, line 873)) frame  is described in more detail on the next page; for now, suffice it to say that the  c  in the leftmost column indicates the presence of a conditional breakpoint upon entry to  sum .  bpref  is a reference to the breakpoint of type  BreakpointRef . The breakpoint  bp  we created can be manipulated at the command line julia> disable(bp)\n\njulia> @interpret sum([1,2,5])\n8\n\njulia> enable(bp)\n\njulia> @interpret sum([1,2,5])\n(Frame for sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873\nc 1* 873  1 ─      nothing\n  2  873  │   %2 = ($(QuoteNode(NamedTuple)))()\n  3  873  │   %3 = Base.pairs(%2)\n⋮\na = [1, 2, 5], breakpoint(sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873, line 873)) disable  and  enable  allow you to turn breakpoints off and on without losing any conditional statements you may have provided;  remove  allows a permanent removal of the breakpoint. You can use  remove()  to remove all breakpoints in all methods. @breakpoint  allows you to optionally specify a line number at which the breakpoint is to be set. You can also use a functional form,  breakpoint , to specify file/line combinations or that you want to break on entry to  any  method of a particular function. At present, note that some of this functionality requires that you be running  Revise.jl . It is, in addition, possible to halt execution when otherwise an error would be thrown. This functionality is enabled using  break_on  and disabled with  break_off : julia> function f_outer()\n           println(\"before error\")\n           f_inner()\n           println(\"after error\")\n       end;\n\njulia> f_inner() = error(\"inner error\");\n\njulia> break_on(:error)\n\njulia> fr, pc = @interpret f_outer()\nbefore error\n(Frame for f_outer() in Main at none:1\n  1  2  1 ─      Base.println(\"before error\")\n  2* 3  │        f_inner()\n  3  4  │   %3 = Base.println(\"after error\")\n  4  4  └──      return %3\ncallee: f_inner() in Main at none:1, breakpoint(error(s::AbstractString) in Base at error.jl:33, line 33, ErrorException(\"inner error\")))\n\njulia> leaf(fr)\nFrame for error(s::AbstractString) in Base at error.jl:33\n  1  33  1 ─ %1 = ($(QuoteNode(ErrorException)))(s)\n  2* 33  │   %2 = Core.throw(%1)\n  3  33  └──      return %2\ns = \"inner error\"\ncaller: f_inner() in Main at none:1\n\njulia> typeof(pc)\nBreakpointRef\n\njulia> pc.err\nErrorException(\"inner error\")\n\njulia> break_off(:error)\n\njulia> @interpret f_outer()\nbefore error\nERROR: inner error\nStacktrace:\n[...] Finally, you can set breakpoints using  @bp : julia> function myfunction(x, y)\n           a = 1\n           b = 2\n           x > 3 && @bp\n           return a + b + x + y\n       end\nmyfunction (generic function with 1 method)\n\njulia> @interpret myfunction(1, 2)\n6\n\njulia> @interpret myfunction(5, 6)\n(Frame for myfunction(x, y) in Main at none:1\n⋮\n  3  4  │   %3 = x > 3\n  4  4  └──      goto #3 if not %3\nb 5* 4  2 ─      nothing\n  6  4  └──      goto #3\n  7  5  3 ┄ %7 = a + b + x + y\n⋮\nx = 5\ny = 6\nb = 2\na = 1, breakpoint(myfunction(x, y) in Main at none:1, line 4)) Here the breakpoint is marked with a  b  indicating that it is an unconditional breakpoint. Because we placed it inside the condition  x > 3 , we've achieved a conditional outcome. When using  @bp  in source-code files, the use of Revise is recommended, since it allows you to add breakpoints, test code, and then remove the breakpoints from the code without restarting Julia."},{"id":32,"pagetitle":"Home","title":"debug_command","ref":"/debug/stable/#debug_command","content":" debug_command You can control execution of frames via  debug_command . Authors of debugging applications should target  debug_command  for their interaction with JuliaInterpreter."},{"id":33,"pagetitle":"Home","title":"Hooks","ref":"/debug/stable/#Hooks","content":" Hooks Consider if you were building a debugging application with a GUI component which displays a dot in the text editor margin where a breakpoint is. If a user creates a breakpoint not via your GUI, but rather via a command in the REPL etc. then you still wish to keep your GUI up to date. How to do this? The answer is hooks. JuliaInterpreter has experimental support for having  a hook, or callback function invoked whenever the set of all breakpoints is changed. Hook functions are setup by invoking the  JuliaInterpreter.on_breakpoints_updated  function. To return to our example of keeping GUI up to date, the hooks would look something like this: using JuliaInterpreter\nusing JuliaInterpreter: AbstractBreakpoint, update_states!, on_breakpoints_updated\n\nbreakpoint_gui_elements = Dict{AbstractBreakpoint, MarginDot}()\n# ...\nfunction breakpoint_gui_hook(::typeof(breakpoint), bp::AbstractBreakpoint)\n    bp_dot = MarginDot(bp)\n    draw(bp_dot)\n    breakpoint_gui_elements[bp] = bp_dot\nend\n\nfunction breakpoint_gui_hook(::typeof(remove), bp::AbstractBreakpoint)\n    bp_dot = pop!(breakpoint_gui_elements, bp)\n    undraw(bp_dot)\nend\n\nfunction breakpoint_gui_hook(::typeof(update_states!), bp::AbstractBreakpoint)\n    is_enabled = bp.enabled[]\n    bp_dot = breakpoint_gui_elements[bp]\n    set_fill!(bp_dot, is_enabled ? :blue : :grey)\nend\n\non_breakpoints_updated(breakpoint_gui_hook)"},{"id":36,"pagetitle":"Lowered representation","title":"Lowered representation","ref":"/debug/stable/ast/#Lowered-representation","content":" Lowered representation JuliaInterpreter uses the lowered representation of code. The key advantage of lowered representation is that it is fairly well circumscribed: There are only a limited number of legal statements that can appear in lowered code Each statement is \"unpacked\" to essentially do one thing Scoping of variables is simplified via the slot mechanism, described below Names are fully resolved by module Macros are expanded Julia AST  describes the kinds of objects that can appear in lowered code. Let's start with a demonstration on a simple function: function summer(A::AbstractArray{T}) where T\n    s = zero(T)\n    for a in A\n        s += a\n    end\n    return s\nend\n\nA = [1, 2, 5] To interpret lowered representation, it maybe be useful to rewrite the body of  summer  in the following ways. First let's use an intermediate representation that expands the  for a in A ... end  loop:     s = zero(T)\n    temp = iterate(A)         # `for` loops get lowered to `iterate/while` loops\n    while temp !== nothing\n        a, state = temp\n        s += a\n        temp = iterate(A, state)\n    end\n    return s The lowered code takes the additional step of resolving the names by module and turning all the branching into  @goto/@label  equivalents:     # Code starting at line 2 (the first line of the body)\n    s = Main.zero(T)       # T corresponds to the first parameter, i.e., $(Expr(:static_parameter, 1))\n\n    # Code starting at line 3\n    temp = Base.iterate(A) # here temp = @_4\n    if temp === nothing    # this comparison gets stored as %4, and %5 stores !(temp===nothing)\n        @goto block4\n    end\n\n    @label block2\n        ## BEGIN block2\n        a, state = temp[1], temp[2]  # these correspond to the `getfield` calls, state is %9\n\n        # Code starting at line 4\n        s = s + a\n\n        # Code starting at line 5\n        temp = iterate(A, state)     # A is also %2\n        if temp === nothing\n            @goto block4             # the `while` condition was false\n        end\n        ## END block2\n\n    @goto block2           # here the `while` condition is still true\n\n    # Code starting at line 6\n    @label block4\n        ## BEGIN block4\n        return s\n        ## END block4 This has very close correspondence to the lowered representation: julia> code = @code_lowered debuginfo=:source summer(A)\nCodeInfo(\n    @ REPL[1]:2 within `summer'\n1 ─       s = Main.zero($(Expr(:static_parameter, 1)))\n│   @ REPL[1]:3 within `summer'\n│   %2  = A\n│         @_4 = Base.iterate(%2)\n│   %4  = @_4 === nothing\n│   %5  = Base.not_int(%4)\n└──       goto #4 if not %5\n2 ┄ %7  = @_4\n│         a = Core.getfield(%7, 1)\n│   %9  = Core.getfield(%7, 2)\n│   @ REPL[1]:4 within `summer'\n│         s = s + a\n│         @_4 = Base.iterate(%2, %9)\n│   %12 = @_4 === nothing\n│   %13 = Base.not_int(%12)\n└──       goto #4 if not %13\n3 ─       goto #2\n    @ REPL[1]:6 within `summer'\n4 ┄       return s\n) Note Not all Julia versions support  debuginfo . If the command above fails for you, just omit the  debuginfo=:source  portion. To understand this package's internals, you need to familiarize yourself with these  CodeInfo  objects. The lines that start with  @ REPL[1]:n  indicate the source line of the succeeding block of statements; here we defined this method in the REPL, so the source file is  REPL[1] ; the number after the colon is the line number. The numbers on the left correspond to  basic blocks , as we annotated with  @label block2  above. When used in statements these are printed with a hash, e.g., in  goto #4 if not %5 , the  #4  refers to basic block 4. The numbers in the next column–e.g.,  %2 , refer to  single static assignment (SSA) values . Each statement (each line of this printout) corresponds to a single SSA value, but only those used later in the code are printed using assignment syntax. Wherever a previous SSA value is used, it's referenced by an  SSAValue  and printed as  %5 ; for example, in  goto #4 if not %5 , the  %5  is the result of evaluating the 5th statement, which is  (Base.not_int)(%4) , which in turn refers to the result of statement 4. Finally, temporary variables here are shown as  @_4 ; the  _  indicates a  slot , either one of the input arguments or a local variable, and the 4 means the 4th one. Together lines 4 and 5 correspond to  !(@_4 === nothing) , where  @_4  has been assigned the result of the call to  iterate  occurring on line 3. (In some Julia versions, this may be printed as  #temp# , similar to how we named it in our alternative implementation above.) Let's look at a couple of the fields of the  CodeInfo . First, the statements themselves: julia> code.code\n16-element Array{Any,1}:\n :(_3 = Main.zero($(Expr(:static_parameter, 1))))\n :(_2)\n :(_4 = Base.iterate(%2))\n :(_4 === nothing)\n :(Base.not_int(%4))\n :(unless %5 goto %16)\n :(_4)\n :(_5 = Core.getfield(%7, 1))\n :(Core.getfield(%7, 2))\n :(_3 = _3 + _5)\n :(_4 = Base.iterate(%2, %9))\n :(_4 === nothing)\n :(Base.not_int(%12))\n :(unless %13 goto %16)\n :(goto %7)\n :(return _3) You can see directly that the SSA assignments are implicit; they are not directly present in the statement list. The most noteworthy change here is the appearance of more objects like  _3 , which are references that index into local variable slots: julia> code.slotnames\n5-element Array{Any,1}:\n Symbol(\"#self#\")\n :A\n :s\n Symbol(\"\")\n :a When printing the whole  CodeInfo  object, these  slotnames  are substituted in (unless they are empty, as was the case for  @_4  above)."},{"id":39,"pagetitle":"Function reference","title":"Function reference","ref":"/debug/stable/dev_reference/#Function-reference","content":" Function reference"},{"id":40,"pagetitle":"Function reference","title":"Running the interpreter","ref":"/debug/stable/dev_reference/#Running-the-interpreter","content":" Running the interpreter"},{"id":41,"pagetitle":"Function reference","title":"JuliaInterpreter.@interpret","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@interpret","content":" JuliaInterpreter.@interpret  —  Macro @interpret f(args; kwargs...) Evaluate  f  on the specified arguments using the interpreter. Example julia> a = [1, 7]\n2-element Vector{Int64}:\n 1\n 7\n\njulia> sum(a)\n8\n\njulia> @interpret sum(a)\n8 source"},{"id":42,"pagetitle":"Function reference","title":"Frame creation","ref":"/debug/stable/dev_reference/#Frame-creation","content":" Frame creation"},{"id":43,"pagetitle":"Function reference","title":"JuliaInterpreter.Frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Frame-Tuple{Module, Expr}","content":" JuliaInterpreter.Frame  —  Method frame = Frame(mod::Module, ex::Expr) Construct a  Frame  to evaluate  ex  in module  mod . This constructor can error, for example if lowering  ex  results in an  :error  or  :incomplete  expression, or if it otherwise fails to return a  :thunk . source"},{"id":44,"pagetitle":"Function reference","title":"JuliaInterpreter.ExprSplitter","ref":"/debug/stable/dev_reference/#JuliaInterpreter.ExprSplitter","content":" JuliaInterpreter.ExprSplitter  —  Type ExprSplitter(mod::Module, ex::Expr; lnn=nothing) Create an iterable that returns individual expressions together with their module of evaluation. Optionally supply an initial  LineNumberNode lnn . Example julia> expr = quote\n           public(x::Integer) = true\n           module Private\n           private(y::String) = false\n           end\n           const threshold = 0.1\n       end;\n\njulia> for (mod, ex) in ExprSplitter(Main, expr)\n           @show mod ex\n       end\nmod = Main\nex = quote\n    #= REPL[7]:2 =#\n    public(x::Integer) = begin\n            #= REPL[7]:2 =#\n            true\n        end\nend\nmod = Main.Private\nex = quote\n    #= REPL[7]:4 =#\n    private(y::String) = begin\n            #= REPL[7]:4 =#\n            false\n        end\nend\nmod = Main\nex = :($(Expr(:toplevel, :(()), :(const threshold = 0.1)))) Note that  Main.Private  was created for you so that its internal expressions could be evaluated.  ExprSplitter  will check to see whether the module already exists and if so return it rather than try to create a new module with the same name. In general each returned expression is a block with two parts: a  LineNumberNode  followed by a single expression. In some cases the returned expression may be  :toplevel , as shown in the  const  declaration, but otherwise it will be a  :block . World age, frame creation, and evaluation The primary purpose of  ExprSplitter  is to allow sequential return to top-level (e.g., the REPL) after evaluation of each expression. Returning to top-level allows the world age to update, and hence allows one to call methods and use types defined in earlier expressions in a block. For evaluation by JuliaInterpreter, the returned module/expression pairs can be passed directly to the  Frame  constructor. However, some expressions cannot be converted into  Frame s and may need special handling: julia> for (mod, ex) in ExprSplitter(Main, expr)\n           if ex.head === :global\n               # global declarations can't be lowered to a CodeInfo.\n               # In this demo we choose to evaluate them, but you can do something else.\n               Core.eval(mod, ex)\n               continue\n           end\n           frame = Frame(mod, ex)\n           debug_command(frame, :c, true)\n       end\n\njulia> threshold\n0.1\n\njulia> public(3)\ntrue If you're parsing package code,  ex  might be a docstring-expression; you may wish to check for such expressions and take distinct actions. See  Frame(mod::Module, ex::Expr)  for more information about frame creation. source"},{"id":45,"pagetitle":"Function reference","title":"JuliaInterpreter.enter_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enter_call","content":" JuliaInterpreter.enter_call  —  Function frame = enter_call(f, args...; kwargs...) Build a  Frame  ready to execute  f  with the specified positional and keyword arguments. Example julia> mymethod(x) = x+1\nmymethod (generic function with 1 method)\n\njulia> JuliaInterpreter.enter_call(mymethod, 1)\nFrame for mymethod(x) in Main at none:1\n  1* 1  1 ─ %1 = x + 1\n  2  1  └──      return %1\nx = 1\n\njulia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 2 methods)\n\njulia> JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])\nFrame for mymethod(x::Vector{T}) where T in Main at none:1\n  1* 1  1 ─     return 1\nx = [1.0, 2.0]\nT = Float64 For a  @generated  function you can use  enter_call((f, true), args...; kwargs...)  to execute the generator of a  @generated  function, rather than the code that would be created by the generator. See  enter_call_expr  for a similar approach based on expressions. source"},{"id":46,"pagetitle":"Function reference","title":"JuliaInterpreter.enter_call_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enter_call_expr","content":" JuliaInterpreter.enter_call_expr  —  Function frame = enter_call_expr(expr; enter_generated=false) Build a  Frame  ready to execute the expression  expr . Set  enter_generated=true  if you want to execute the generator of a  @generated  function, rather than the code that would be created by the generator. Example julia> mymethod(x) = x+1\nmymethod (generic function with 1 method)\n\njulia> JuliaInterpreter.enter_call_expr(:($mymethod(1)))\nFrame for mymethod(x) in Main at none:1\n  1* 1  1 ─ %1 = x + 1\n  2  1  └──      return %1\nx = 1\n\njulia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 2 methods)\n\njulia> a = [1.0, 2.0]\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> JuliaInterpreter.enter_call_expr(:($mymethod($a)))\nFrame for mymethod(x::Vector{T}) where T in Main at none:1\n  1* 1  1 ─     return 1\nx = [1.0, 2.0]\nT = Float64 See  enter_call  for a similar approach not based on expressions. source"},{"id":47,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_frame","content":" JuliaInterpreter.prepare_frame  —  Function frame = prepare_frame(framecode::FrameCode, frameargs, lenv) Construct a new  Frame  for  framecode , given lowered-code arguments  frameargs  and static parameters  lenv . See  JuliaInterpreter.prepare_call  for information about how to prepare the inputs. source"},{"id":48,"pagetitle":"Function reference","title":"JuliaInterpreter.determine_method_for_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.determine_method_for_expr","content":" JuliaInterpreter.determine_method_for_expr  —  Function framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false) Prepare all the information needed to execute a particular  :call  expression  expr . For example, try  JuliaInterpreter.determine_method_for_expr(:($sum([1,2]))) . See  JuliaInterpreter.prepare_call  for information about the outputs. source"},{"id":49,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_args","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_args","content":" JuliaInterpreter.prepare_args  —  Function frun, allargs = prepare_args(fcall, fargs, kwargs) Prepare the complete argument sequence for a call to  fcall .  fargs = [fcall, args...]  is a list containing both  fcall  (the  #self#  slot in lowered code) and the positional arguments supplied to  fcall .  kwargs  is a list of keyword arguments, supplied either as list of expressions  :(kwname=kwval)  or pairs  :kwname=>kwval . For non-keyword methods,  frun === fcall , but for methods with keywords  frun  will be the keyword-sorter function for  fcall . Example julia> mymethod(x) = 1\nmymethod (generic function with 1 method)\n\njulia> mymethod(x, y; verbose=false) = nothing\nmymethod (generic function with 2 methods)\n\njulia> JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())\n(mymethod, Any[mymethod, 15])\n\njulia> JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=>true])\n(var\"#mymethod##kw\"(), Any[var\"#mymethod##kw\"(), (verbose = true,), mymethod, 1, 2]) source"},{"id":50,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_call","content":" JuliaInterpreter.prepare_call  —  Function framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false) Prepare all the information needed to execute lowered code for  f  given arguments  allargs .  f  and  allargs  are the outputs of  prepare_args . For  @generated  methods, set  enter_generated=true  if you want to extract the lowered code of the generator itself. On return  framecode  is the  FrameCode  of the method.  frameargs  contains the actual arguments needed for executing this frame (for generators, this will be the types of  allargs );  lenv  is the \"environment\", i.e., the static parameters for  f  given  allargs .  argtypes  is the  Tuple -type for this specific call (equivalent to the signature of the  MethodInstance ). Example julia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 1 method)\n\njulia> framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);\n\njulia> framecode\n  1  1  1 ─     return 1\n\njulia> frameargs\n2-element Vector{Any}:\n mymethod (generic function with 1 method)\n [1.0, 2.0]\n\njulia> lenv\nsvec(Float64)\n\njulia> argtypes\nTuple{typeof(mymethod), Vector{Float64}} source"},{"id":51,"pagetitle":"Function reference","title":"JuliaInterpreter.get_call_framecode","ref":"/debug/stable/dev_reference/#JuliaInterpreter.get_call_framecode","content":" JuliaInterpreter.get_call_framecode  —  Function framecode, lenv = get_call_framecode(fargs, parentframe::FrameCode, idx::Int) Return the framecode and environment for a call specified by  fargs = [f, args...]  (see  prepare_args ).  parentframecode  is the caller, and  idx  is the program-counter index. If possible,  framecode  will be looked up from the local method tables of  parentframe . source"},{"id":52,"pagetitle":"Function reference","title":"JuliaInterpreter.optimize!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.optimize!","content":" JuliaInterpreter.optimize!  —  Function optimize!(code::CodeInfo, mod::Module) Perform minor optimizations on the lowered AST in  code  to reduce execution time of the interpreter. Currently it looks up  GlobalRef s (for which it needs  mod  to know the scope in which this will run) and ensures that no statement includes nested  :call  expressions (splitting them out into multiple SSA-form statements if needed). source"},{"id":53,"pagetitle":"Function reference","title":"Frame traversal","ref":"/debug/stable/dev_reference/#Frame-traversal","content":" Frame traversal"},{"id":54,"pagetitle":"Function reference","title":"JuliaInterpreter.root","ref":"/debug/stable/dev_reference/#JuliaInterpreter.root","content":" JuliaInterpreter.root  —  Function rframe = root(frame) Return the initial frame in the call stack. source"},{"id":55,"pagetitle":"Function reference","title":"JuliaInterpreter.leaf","ref":"/debug/stable/dev_reference/#JuliaInterpreter.leaf","content":" JuliaInterpreter.leaf  —  Function lframe = leaf(frame) Return the deepest callee in the call stack. source"},{"id":56,"pagetitle":"Function reference","title":"Frame execution","ref":"/debug/stable/dev_reference/#Frame-execution","content":" Frame execution"},{"id":57,"pagetitle":"Function reference","title":"JuliaInterpreter.Compiled","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Compiled","content":" JuliaInterpreter.Compiled  —  Type Compiled  is a trait indicating that any  :call  expressions should be evaluated using Julia's normal compiled-code evaluation. The alternative is to pass  stack=Frame[] , which will cause all calls to be evaluated via the interpreter. source"},{"id":58,"pagetitle":"Function reference","title":"JuliaInterpreter.step_expr!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.step_expr!","content":" JuliaInterpreter.step_expr!  —  Function pc = step_expr!(recurse, frame, istoplevel=false)\npc = step_expr!(frame, istoplevel=false) Execute the next statement in  frame .  pc  is the new program counter, or  nothing  if execution terminates, or a  BreakpointRef  if execution hits a breakpoint. recurse  controls call evaluation;  recurse = Compiled()  evaluates :call expressions by normal dispatch. The default value  recurse = finish_and_return!  will use recursive interpretation. If you are evaluating  frame  at module scope you should pass  istoplevel=true . source"},{"id":59,"pagetitle":"Function reference","title":"JuliaInterpreter.finish!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish!","content":" JuliaInterpreter.finish!  —  Function pc = finish!(recurse, frame, istoplevel=false)\npc = finish!(frame, istoplevel=false) Run  frame  until execution terminates.  pc  is either  nothing  (if execution terminates when it hits a  return  statement) or a reference to a breakpoint. In the latter case,  leaf(frame)  returns the frame in which it hit the breakpoint. recurse  controls call evaluation;  recurse = Compiled()  evaluates :call expressions by normal dispatch, whereas the default  recurse = finish_and_return!  uses recursive interpretation. source"},{"id":60,"pagetitle":"Function reference","title":"JuliaInterpreter.finish_and_return!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish_and_return!","content":" JuliaInterpreter.finish_and_return!  —  Function ret = finish_and_return!(recurse, frame, istoplevel::Bool=false)\nret = finish_and_return!(frame, istoplevel::Bool=false) Call  JuliaInterpreter.finish!  and pass back the return value  ret . If execution pauses at a breakpoint,  ret  is the reference to the breakpoint. source"},{"id":61,"pagetitle":"Function reference","title":"JuliaInterpreter.finish_stack!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish_stack!","content":" JuliaInterpreter.finish_stack!  —  Function ret = finish_stack!(recurse, frame, rootistoplevel=false)\nret = finish_stack!(frame, rootistoplevel=false) Unwind the callees of  frame , finishing each before returning to the caller.  frame  itself is also finished.  rootistoplevel  should be true if the root frame is top-level. ret  is typically the returned value. If execution hits a breakpoint,  ret  will be a reference to the breakpoint. source"},{"id":62,"pagetitle":"Function reference","title":"JuliaInterpreter.get_return","ref":"/debug/stable/dev_reference/#JuliaInterpreter.get_return","content":" JuliaInterpreter.get_return  —  Function ret = get_return(frame) Get the return value of  frame . Throws an error if  frame.pc  does not point to a  return  expression.  frame  must have already been executed so that the return value has been computed (see, e.g.,  JuliaInterpreter.finish! ). source"},{"id":63,"pagetitle":"Function reference","title":"JuliaInterpreter.next_until!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_until!","content":" JuliaInterpreter.next_until!  —  Function pc = next_until!(predicate, recurse, frame, istoplevel=false)\npc = next_until!(predicate, frame, istoplevel=false) Execute the current statement. Then step through statements of  frame  until the next statement satisfies  predicate(frame) .  pc  will be the index of the statement at which evaluation terminates,  nothing  (if the frame reached a  return ), or a  BreakpointRef . source"},{"id":64,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_next_until!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_next_until!","content":" JuliaInterpreter.maybe_next_until!  —  Function pc = maybe_next_until!(predicate, recurse, frame, istoplevel=false)\npc = maybe_next_until!(predicate, frame, istoplevel=false) Like  next_until!  except checks  predicate  before executing the current statment. source"},{"id":65,"pagetitle":"Function reference","title":"JuliaInterpreter.through_methoddef_or_done!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.through_methoddef_or_done!","content":" JuliaInterpreter.through_methoddef_or_done!  —  Function pc = through_methoddef_or_done!(recurse, frame)\npc = through_methoddef_or_done!(frame) Runs  frame  at top level until it either finishes (e.g., hits a  return  statement) or defines a new method. source"},{"id":66,"pagetitle":"Function reference","title":"JuliaInterpreter.evaluate_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.evaluate_call!","content":" JuliaInterpreter.evaluate_call!  —  Function ret = evaluate_call!(Compiled(), frame::Frame, call_expr)\nret = evaluate_call!(recurse,    frame::Frame, call_expr) Evaluate a  :call  expression  call_expr  in the context of  frame . The first causes it to be executed using Julia's normal dispatch (compiled code), whereas the second recurses in via the interpreter.  recurse  has a default value of  JuliaInterpreter.finish_and_return! . source"},{"id":67,"pagetitle":"Function reference","title":"JuliaInterpreter.evaluate_foreigncall","ref":"/debug/stable/dev_reference/#JuliaInterpreter.evaluate_foreigncall","content":" JuliaInterpreter.evaluate_foreigncall  —  Function ret = evaluate_foreigncall(recurse, frame::Frame, call_expr) Evaluate a  :foreigncall  (from a  ccall ) statement  callexpr  in the context of  frame . source"},{"id":68,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_evaluate_builtin","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_evaluate_builtin","content":" JuliaInterpreter.maybe_evaluate_builtin  —  Function ret = maybe_evaluate_builtin(frame, call_expr, expand::Bool) If  call_expr  is to a builtin function, evaluate it, returning the result inside a  Some  wrapper. Otherwise, return  call_expr . If  expand  is true,  Core._apply_iterate  calls will be resolved as a call to the applied function. source"},{"id":69,"pagetitle":"Function reference","title":"JuliaInterpreter.next_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_call!","content":" JuliaInterpreter.next_call!  —  Function pc = next_call!(recurse, frame, istoplevel=false)\npc = next_call!(frame, istoplevel=false) Execute the current statement. Continue stepping through  frame  until the next  :return  or  :call  expression. source"},{"id":70,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_next_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_next_call!","content":" JuliaInterpreter.maybe_next_call!  —  Function pc = maybe_next_call!(recurse, frame, istoplevel=false)\npc = maybe_next_call!(frame, istoplevel=false) Return the current program counter of  frame  if it is a  :return  or  :call  expression. Otherwise, step through the statements of  frame  until the next  :return  or  :call  expression. source"},{"id":71,"pagetitle":"Function reference","title":"JuliaInterpreter.next_line!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_line!","content":" JuliaInterpreter.next_line!  —  Function pc = next_line!(recurse, frame, istoplevel=false)\npc = next_line!(frame, istoplevel=false) Execute until reaching the first call of the next line of the source code. Upon return,  pc  is either the new program counter,  nothing  if a  return  is reached, or a  BreakpointRef  if it encountered a wrapper call. In the latter case, call  leaf(frame)  to obtain the new execution frame. source"},{"id":72,"pagetitle":"Function reference","title":"JuliaInterpreter.until_line!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.until_line!","content":" JuliaInterpreter.until_line!  —  Function pc = until_line!(recurse, frame, line=nothing istoplevel=false)\npc = until_line!(frame, line=nothing, istoplevel=false) Execute until the current frame reaches a line greater than  line . If  line == nothing  execute until the current frame reaches any line greater than the current line. source"},{"id":73,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_reset_frame!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_reset_frame!","content":" JuliaInterpreter.maybe_reset_frame!  —  Function ret = maybe_reset_frame!(recurse, frame, pc, rootistoplevel) Perform a return to the caller, or descend to the level of a breakpoint.  pc  is the return state from the previous command (e.g.,  next_call!  or similar).  rootistoplevel  should be true if the root frame is top-level. ret  will be  nothing  if we have just completed a top-level frame. Otherwise, cframe, cpc = ret where  cframe  is the frame from which execution should continue and  cpc  is the state of  cframe  (the program counter, a  BreakpointRef , or  nothing ). source"},{"id":74,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_step_through_wrapper!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_step_through_wrapper!","content":" JuliaInterpreter.maybe_step_through_wrapper!  —  Function cframe = maybe_step_through_wrapper!(recurse, frame)\ncframe = maybe_step_through_wrapper!(frame) Return the new frame of execution, potentially stepping through \"wrapper\" methods like those that supply default positional arguments or handle keywords.  cframe  is the leaf frame from which execution should start. source"},{"id":75,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_step_through_kwprep!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_step_through_kwprep!","content":" JuliaInterpreter.maybe_step_through_kwprep!  —  Function frame = maybe_step_through_kwprep!(recurse, frame)\nframe = maybe_step_through_kwprep!(frame) If  frame.pc  points to the beginning of preparatory work for calling a keyword-argument function, advance forward until the actual call. source"},{"id":76,"pagetitle":"Function reference","title":"JuliaInterpreter.handle_err","ref":"/debug/stable/dev_reference/#JuliaInterpreter.handle_err","content":" JuliaInterpreter.handle_err  —  Function loc = handle_err(recurse, frame, err) Deal with an error  err  that arose while evaluating  frame . There are one of three behaviors: if  frame  catches the error,  loc  is the program counter at which to resume evaluation of  frame ; if  frame  doesn't catch the error, but  break_on_error[]  is  true ,  loc  is a  BreakpointRef ; otherwise,  err  gets rethrown. source"},{"id":77,"pagetitle":"Function reference","title":"JuliaInterpreter.debug_command","ref":"/debug/stable/dev_reference/#JuliaInterpreter.debug_command","content":" JuliaInterpreter.debug_command  —  Function ret = debug_command(recurse, frame, cmd, rootistoplevel=false; line=nothing)\nret = debug_command(frame, cmd, rootistoplevel=false; line=nothing) Perform one \"debugger\" command. The keyword arguments are not used for all debug commands.  cmd  should be one of: :n : advance to the next line :s : step into the next call :sl  step into the last call on the current line (e.g. steps into  f  if the line is  f(g(h(x))) ). :until : advance the frame to line  line  if given, otherwise advance to the line after the current line :c : continue execution until termination or reaching a breakpoint :finish : finish the current frame and return to the parent or one of the 'advanced' commands :nc : step forward to the next call :se : execute a single statement :si : execute a single statement, stepping in if it's a call :sg : step into the generator of a generated function rootistoplevel  and  ret  are as described for  JuliaInterpreter.maybe_reset_frame! . source"},{"id":78,"pagetitle":"Function reference","title":"Breakpoints","ref":"/debug/stable/dev_reference/#Breakpoints","content":" Breakpoints"},{"id":79,"pagetitle":"Function reference","title":"JuliaInterpreter.@breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@breakpoint","content":" JuliaInterpreter.@breakpoint  —  Macro @breakpoint f(args...) condition=nothing\n@breakpoint f(args...) line condition=nothing Break upon entry, or at the specified line number, in the method called by  f(args...) . Optionally supply a condition expressed in terms of the arguments and internal variables of the method. If  line  is supplied, it must be a literal integer. Example Suppose a method  mysum  is defined as follows, where the numbers to the left are the line number in the file: 12 function mysum(A)\n13     s = zero(eltype(A))\n14     for a in A\n15         s += a\n16     end\n17     return s\n18 end Then @breakpoint mysum(A) 15 s>10 would cause execution of the loop to break whenever  s>10 . source"},{"id":80,"pagetitle":"Function reference","title":"JuliaInterpreter.@bp","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@bp","content":" JuliaInterpreter.@bp  —  Macro @bp Insert a breakpoint at a location in the source code. source"},{"id":81,"pagetitle":"Function reference","title":"JuliaInterpreter.breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.breakpoint","content":" JuliaInterpreter.breakpoint  —  Function breakpoint(f, [sig], [line], [condition]) Add a breakpoint to  f  with the specified argument types  sig .¨ If  sig  is not given, the breakpoint will apply to all methods of  f . If  f  is a method, the breakpoint will only apply to that method. Optionally specify an absolute line number  line  in the source file; the default is to break upon entry at the first line of the body. Without  condition , the breakpoint will be triggered every time it is encountered; the second only if  condition  evaluates to  true .  condition  should be written in terms of the arguments and local variables of  f . Example function radius2(x, y)\n    return x^2 + y^2\nend\n\nbreakpoint(radius2, Tuple{Int,Int}, :(y > x)) source breakpoint(file, line, [condition]) Set a breakpoint in  file  at  line . The argument  file  can be a filename, a partial path or absolute path. For example,  file = foo.jl  will match against all files with the name  foo.jl ,  file = src/foo.jl  will match against all paths containing  src/foo.jl , e.g. both  Foo/src/foo.jl  and  Bar/src/foo.jl . Absolute paths only matches against the file with that exact absolute path. source"},{"id":82,"pagetitle":"Function reference","title":"JuliaInterpreter.enable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enable","content":" JuliaInterpreter.enable  —  Function enable(bp::AbstractBreakpoint) Enable breakpoint  bp . source enable() Enable all breakpoints. source"},{"id":83,"pagetitle":"Function reference","title":"JuliaInterpreter.disable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.disable","content":" JuliaInterpreter.disable  —  Function disable(bp::AbstractBreakpoint) Disable breakpoint  bp . Disabled breakpoints can be re-enabled with  enable . source disable() Disable all breakpoints. source"},{"id":84,"pagetitle":"Function reference","title":"JuliaInterpreter.remove","ref":"/debug/stable/dev_reference/#JuliaInterpreter.remove","content":" JuliaInterpreter.remove  —  Function remove(bp::AbstractBreakpoint) Remove (delete) breakpoint  bp . Removed breakpoints cannot be re-enabled. source remove() Remove all breakpoints. source"},{"id":85,"pagetitle":"Function reference","title":"JuliaInterpreter.toggle","ref":"/debug/stable/dev_reference/#JuliaInterpreter.toggle","content":" JuliaInterpreter.toggle  —  Function toggle(bp::AbstractBreakpoint) Toggle breakpoint  bp . source"},{"id":86,"pagetitle":"Function reference","title":"JuliaInterpreter.break_on","ref":"/debug/stable/dev_reference/#JuliaInterpreter.break_on","content":" JuliaInterpreter.break_on  —  Function break_on(states...) Turn on automatic breakpoints when any of the conditions described in  states  occurs. The supported states are: :error : trigger a breakpoint any time an uncaught exception is thrown :throw  : trigger a breakpoint any time a throw is executed (even if it will eventually be caught) source"},{"id":87,"pagetitle":"Function reference","title":"JuliaInterpreter.break_off","ref":"/debug/stable/dev_reference/#JuliaInterpreter.break_off","content":" JuliaInterpreter.break_off  —  Function break_off(states...) Turn off automatic breakpoints when any of the conditions described in  states  occurs. See  break_on  for a description of valid states. source"},{"id":88,"pagetitle":"Function reference","title":"JuliaInterpreter.breakpoints","ref":"/debug/stable/dev_reference/#JuliaInterpreter.breakpoints","content":" JuliaInterpreter.breakpoints  —  Function breakpoints()::Vector{AbstractBreakpoint} Return an array with all breakpoints. source"},{"id":89,"pagetitle":"Function reference","title":"JuliaInterpreter.dummy_breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.dummy_breakpoint","content":" JuliaInterpreter.dummy_breakpoint  —  Function bpref = dummy_breakpoint(recurse, frame::Frame, istoplevel) Return a fake breakpoint.  dummy_breakpoint  can be useful as the  recurse  argument to  evaluate_call!  (or any of the higher-order commands) to ensure that you return immediately after stepping into a call. source"},{"id":90,"pagetitle":"Function reference","title":"Types","ref":"/debug/stable/dev_reference/#Types","content":" Types"},{"id":91,"pagetitle":"Function reference","title":"JuliaInterpreter.Frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Frame","content":" JuliaInterpreter.Frame  —  Type Frame  represents the current execution state in a particular call frame. Fields: framecode : the  FrameCode  for this frame. framedata : the  FrameData  for this frame. pc : the program counter (integer index of the next statment to be evaluated) for this frame. caller : the parent caller of this frame, or  nothing . callee : the frame called by this one, or  nothing . The  Base  functions  show_backtrace  and  display_error  are overloaded such that  show_backtrace(io::IO, frame::Frame)  and  display_error(io::IO, er, frame::Frame)  shows a backtrace or error, respectively, in a similar way as to how Base shows them. source"},{"id":92,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameCode","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameCode","content":" JuliaInterpreter.FrameCode  —  Type FrameCode  holds static information about a method or toplevel code. One  FrameCode  can be shared by many calling  Frame s. Important fields: scope : the  Method  or  Module  in which this frame is to be evaluated. src : the  CodeInfo  object storing (optimized) lowered source code. methodtables : a vector, each entry potentially stores a \"local method table\" for the corresponding  :call  expression in  src  (undefined entries correspond to statements that do not contain  :call  expressions). used : a  BitSet  storing the list of SSAValues that get referenced by later statements. source"},{"id":93,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameData","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameData","content":" JuliaInterpreter.FrameData  —  Type FrameData  holds the arguments, local variables, and intermediate execution state in a particular call frame. Important fields: locals : a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in the  slotnames  of the src. Use  locals  to extract the current value of local variables. ssavalues : a vector containing the  Static Single Assignment  values produced at the current state of execution. sparams : the static type parameters, e.g., for  f(x::Vector{T}) where T  this would store the value of  T  given the particular input  x . exception_frames : a list of indexes to  catch  blocks for handling exceptions within the current frame. The active handler is the last one on the list. last_exception : the exception  throw n by this frame or one of its callees. source"},{"id":94,"pagetitle":"Function reference","title":"JuliaInterpreter._INACTIVE_EXCEPTION","ref":"/debug/stable/dev_reference/#JuliaInterpreter._INACTIVE_EXCEPTION","content":" JuliaInterpreter._INACTIVE_EXCEPTION  —  Type _INACTIVE_EXCEPTION Represents a case where no exceptions are thrown yet. End users will not see this singleton type, otherwise it usually means there is missing error handling in the interpretation process. source"},{"id":95,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameInstance","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameInstance","content":" JuliaInterpreter.FrameInstance  —  Type FrameInstance  represents a method specialized for particular argument types. Fields: framecode : the  FrameCode  for the method. sparam_vals : the static parameter values for the method. source"},{"id":96,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointState","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointState","content":" JuliaInterpreter.BreakpointState  —  Type BreakpointState(isactive=true, condition=JuliaInterpreter.truecondition) BreakpointState  represents a breakpoint at a particular statement in a  FrameCode .  isactive  indicates whether the breakpoint is currently  enable d or  disable d.  condition  is a function that accepts a single  Frame , and  condition(frame)  must return either  true  or  false . Execution will stop at a breakpoint only if  isactive  and  condition(frame)  both evaluate as  true . The default  condition  always returns  true . To create these objects, see  breakpoint . source"},{"id":97,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointRef","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointRef","content":" JuliaInterpreter.BreakpointRef  —  Type BreakpointRef(framecode, stmtidx)\nBreakpointRef(framecode, stmtidx, err) A reference to a breakpoint at a particular statement index  stmtidx  in  framecode . If the break was due to an error, supply that as well. Commands that execute complex control-flow (e.g.,  next_line! ) may also return a  BreakpointRef  to indicate that the execution stack switched frames, even when no breakpoint has been set at the corresponding statement. source"},{"id":98,"pagetitle":"Function reference","title":"JuliaInterpreter.AbstractBreakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.AbstractBreakpoint","content":" JuliaInterpreter.AbstractBreakpoint  —  Type AbstractBreakpoint  is the abstract type that is the supertype for breakpoints. Currently, the concrete breakpoint types  BreakpointSignature  and  BreakpointFileLocation  exist. Common fields shared by the concrete breakpoints: condition::Union{Nothing,Expr,Tuple{Module,Expr}} : the condition when the breakpoint applies .  nothing  means unconditionally, otherwise when the  Expr  (optionally in  Module ). enabled::Ref{Bool} : If the breakpoint is enabled (should not be directly modified, use  enable()  or  disable() ). instances::Vector{BreakpointRef} : All the  BreakpointRef  that the breakpoint has applied to. line::Int  The line of the breakpoint (equal to 0 if unset). See  BreakpointSignature  and  BreakpointFileLocation  for additional fields in the concrete types. source"},{"id":99,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointSignature","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointSignature","content":" JuliaInterpreter.BreakpointSignature  —  Type A  BreakpointSignature  is a breakpoint that is set on methods or functions. Fields: f::Union{Method, Function, Type} : A method or function that the breakpoint should apply to. sig::Union{Nothing, Type} : if  f  is a  Method , always equal to  nothing . Otherwise, contains the method signature  as a tuple type for what methods the breakpoint should apply to. For common fields shared by all breakpoints, see  AbstractBreakpoint . source"},{"id":100,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointFileLocation","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointFileLocation","content":" JuliaInterpreter.BreakpointFileLocation  —  Type A  BreakpointFileLocation  is a breakpoint that is set on a line in a file. Fields: path::String : The literal string that was used to create the breakpoint, e.g.  \"path/file.jl\" . abspath ::String: The absolute path to the file when the breakpoint was created, e.g.  \"/Users/Someone/path/file.jl\" . For common fields shared by all breakpoints, see  AbstractBreakpoint . source"},{"id":101,"pagetitle":"Function reference","title":"Internal storage","ref":"/debug/stable/dev_reference/#Internal-storage","content":" Internal storage"},{"id":102,"pagetitle":"Function reference","title":"JuliaInterpreter.framedict","ref":"/debug/stable/dev_reference/#JuliaInterpreter.framedict","content":" JuliaInterpreter.framedict  —  Constant framedict[method]  returns the  FrameCode  for  method . For  @generated  methods, see  genframedict . source"},{"id":103,"pagetitle":"Function reference","title":"JuliaInterpreter.genframedict","ref":"/debug/stable/dev_reference/#JuliaInterpreter.genframedict","content":" JuliaInterpreter.genframedict  —  Constant genframedict[(method,argtypes)]  returns the  FrameCode  for a  @generated  method  method , for the particular argument types  argtypes . The framecodes stored in  genframedict  are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in  framedict . source"},{"id":104,"pagetitle":"Function reference","title":"JuliaInterpreter.compiled_methods","ref":"/debug/stable/dev_reference/#JuliaInterpreter.compiled_methods","content":" JuliaInterpreter.compiled_methods  —  Constant meth ∈ compiled_methods  indicates that  meth  should be run using  Compiled  rather than recursed into via the interpreter. source"},{"id":105,"pagetitle":"Function reference","title":"JuliaInterpreter.compiled_modules","ref":"/debug/stable/dev_reference/#JuliaInterpreter.compiled_modules","content":" JuliaInterpreter.compiled_modules  —  Constant mod ∈ compiled_modules  indicates that any method in  mod  should be run using  Compiled  rather than recursed into via the interpreter. source"},{"id":106,"pagetitle":"Function reference","title":"JuliaInterpreter.interpreted_methods","ref":"/debug/stable/dev_reference/#JuliaInterpreter.interpreted_methods","content":" JuliaInterpreter.interpreted_methods  —  Constant meth ∈ interpreted_methods  indicates that  meth  should  not  be run using  Compiled  and recursed into via the interpreter. This takes precedence over  compiled_methods  and  compiled_modules . source"},{"id":107,"pagetitle":"Function reference","title":"Utilities","ref":"/debug/stable/dev_reference/#Utilities","content":" Utilities"},{"id":108,"pagetitle":"Function reference","title":"JuliaInterpreter.eval_code","ref":"/debug/stable/dev_reference/#JuliaInterpreter.eval_code","content":" JuliaInterpreter.eval_code  —  Function eval_code(frame::Frame, code::Union{String, Expr}) Evaluate  code  in the context of  frame , updating any local variables (including type parameters) that are reassigned in  code , however, new local variables cannot be introduced. julia> foo(x, y) = x + y;\n\njulia> frame = JuliaInterpreter.enter_call(foo, 1, 3);\n\njulia> JuliaInterpreter.eval_code(frame, \"x + y\")\n4\n\njulia> JuliaInterpreter.eval_code(frame, \"x = 5\");\n\njulia> JuliaInterpreter.finish_and_return!(frame)\n8 When variables are captured in closures (and thus gets wrapped in a  Core.Box ) they will be automatically unwrapped and rewrapped upon evaluating them: julia> function capture()\n           x = 1\n           f = ()->(x = 2) # x captured in closure and is thus a Core.Box\n           f()\n           x\n       end;\n\njulia> frame = JuliaInterpreter.enter_call(capture);\n\njulia> JuliaInterpreter.step_expr!(frame);\n\njulia> JuliaInterpreter.step_expr!(frame);\n\njulia> JuliaInterpreter.locals(frame)\n2-element Vector{JuliaInterpreter.Variable}:\n #self# = capture\n x = Core.Box(1)\n\njulia> JuliaInterpreter.eval_code(frame, \"x\")\n1\n\njulia> JuliaInterpreter.eval_code(frame, \"x = 2\")\n2\n\njulia> JuliaInterpreter.locals(frame)\n2-element Vector{JuliaInterpreter.Variable}:\n #self# = capture\n x = Core.Box(2) \"Special\" values like SSA values and slots (shown in lowered code as e.g.  %3  and  @_4  respectively) can be evaluated using the syntax  var\"%3\"  and  var\"@_4\"  respectively. source"},{"id":109,"pagetitle":"Function reference","title":"JuliaInterpreter.@lookup","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@lookup","content":" JuliaInterpreter.@lookup  —  Macro rhs = @lookup(frame, node)\nrhs = @lookup(mod, frame, node) This macro looks up previously-computed values referenced as SSAValues, SlotNumbers, GlobalRefs, QuoteNode, sparam or exception reference expression. It will also lookup symbols in  moduleof(frame) ; this can be supplied ahead-of-time via the 3-argument version. If none of the above apply, the value of  node  will be returned. source"},{"id":110,"pagetitle":"Function reference","title":"JuliaInterpreter.is_wrapper_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_wrapper_call","content":" JuliaInterpreter.is_wrapper_call  —  Function Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or because of keyword arguments). source"},{"id":111,"pagetitle":"Function reference","title":"JuliaInterpreter.is_doc_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_doc_expr","content":" JuliaInterpreter.is_doc_expr  —  Function is_doc_expr(ex) Test whether expression  ex  is a  @doc  expression. source"},{"id":112,"pagetitle":"Function reference","title":"JuliaInterpreter.is_global_ref","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_global_ref","content":" JuliaInterpreter.is_global_ref  —  Function is_global_ref(g, mod, name) Tests whether  g  is equal to  GlobalRef(mod, name) . source"},{"id":113,"pagetitle":"Function reference","title":"CodeTracking.whereis","ref":"/debug/stable/dev_reference/#CodeTracking.whereis","content":" CodeTracking.whereis  —  Function loc = whereis(frame, pc::Int=frame.pc; macro_caller=false) Return the file and line number for  frame  at  pc .  If this cannot be determined,  loc == nothing . Otherwise  loc == (filepath, line) . By default, any statements expanded from a macro are attributed to the macro definition, but with macro_caller=true  you can obtain the location within the method that issued the macro. source"},{"id":114,"pagetitle":"Function reference","title":"JuliaInterpreter.linenumber","ref":"/debug/stable/dev_reference/#JuliaInterpreter.linenumber","content":" JuliaInterpreter.linenumber  —  Function line = linenumber(framecode, pc) Return the \"static\" line number at statement index  pc . The static line number is the location at the time the method was most recently defined. See  CodeTracking.whereis  for dynamic line information. source"},{"id":115,"pagetitle":"Function reference","title":"JuliaInterpreter.Variable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Variable","content":" JuliaInterpreter.Variable  —  Type Variable  is a struct representing a variable with an asigned value. By calling the function  locals  on a  Frame  a  Vector  of  Variable 's is returned. Important fields: value::Any : the value of the local variable. name::Symbol : the name of the variable as given in the source code. isparam::Bool : if the variable is a type parameter, for example  T  in  f(x::T) where {T} = x . is_captured_closure::Bool : if the variable has been captured by a closure source"},{"id":116,"pagetitle":"Function reference","title":"JuliaInterpreter.locals","ref":"/debug/stable/dev_reference/#JuliaInterpreter.locals","content":" JuliaInterpreter.locals  —  Function local_variables = locals(frame::Frame)::Vector{Variable} Return the local variables as a vector of  Variable . source"},{"id":117,"pagetitle":"Function reference","title":"JuliaInterpreter.whichtt","ref":"/debug/stable/dev_reference/#JuliaInterpreter.whichtt","content":" JuliaInterpreter.whichtt  —  Function method = whichtt(tt) Like  which  except it operates on the complete tuple-type  tt , and doesn't throw when there is no matching method. source"},{"id":118,"pagetitle":"Function reference","title":"Hooks","ref":"/debug/stable/dev_reference/#Hooks","content":" Hooks"},{"id":119,"pagetitle":"Function reference","title":"JuliaInterpreter.on_breakpoints_updated","ref":"/debug/stable/dev_reference/#JuliaInterpreter.on_breakpoints_updated","content":" JuliaInterpreter.on_breakpoints_updated  —  Function on_breakpoints_updated(f) Register a one-argument function to be called after any update to the set of all breakpoints. This includes their creation, deletion, enabling and disabling. The function  f  should take two inputs: First argument is the function doing to update, this is provided to allow to dispatch on its type. It will be one: ::typeof(breakpoint)  for the creation, ::typeof(remove)  for the deletion. ::typeof(update_states)  for disable/enable/toggleing Second argument is the breakpoint object that was changed. If only desiring to handle some kinds of update,  f  should have fallback methods to do nothing in the general case. Warning This feature is experimental, and may be modified or removed in a minor release. source"},{"id":120,"pagetitle":"Function reference","title":"JuliaInterpreter.firehooks","ref":"/debug/stable/dev_reference/#JuliaInterpreter.firehooks","content":" JuliaInterpreter.firehooks  —  Function firehooks(hooked_fun, bp::AbstractBreakpoint) Trigger all hooks that were registered with  on_breakpoints_updated , passing them the  hooked_fun  and the  bp . This should be called whenever the set of breakpoints is updated.  hooked_fun  is the function doing the update, and  bp  is the relevent breakpoint being updated  after  the update is applied. Warning This feature is experimental, and may be modified or removed in a minor release. source"},{"id":123,"pagetitle":"Internals","title":"Internals","ref":"/debug/stable/internals/#Internals","content":" Internals"},{"id":124,"pagetitle":"Internals","title":"Basic usage","ref":"/debug/stable/internals/#Basic-usage","content":" Basic usage The process of executing code in the interpreter is to prepare a  frame  and then evaluate these statements one-by-one, branching via the  goto  statements as appropriate. Using the  summer  example described in  Lowered representation , let's build a frame: julia> frame = JuliaInterpreter.enter_call(summer, A)\nFrame for summer(A::AbstractArray{T,N} where N) where T in Main at REPL[2]:2\n   1* 2  1 ─       s = (zero)($(Expr(:static_parameter, 1)))\n   2  3  │   %2  = A\n   3  3  │         #temp# = (iterate)(%2)\n⋮\nA = [1, 2, 5]\nT = Int64 This is a  Frame . Only a portion of the  CodeInfo  is shown, a small region surrounding the current statement (marked with  *  or in yellow text). The full  CodeInfo  can be extracted as  code = frame.framecode.src . (It's a slightly modified form of one returned by  @code_lowered , in that it has been processed by  JuliaInterpreter.optimize!  to speed up run-time execution.) frame  has another field,  framedata , that holds values needed for or generated by execution. The input arguments and local variables are in  locals : julia> frame.framedata.locals\n5-element Array{Union{Nothing, Some{Any}},1}:\n Some(summer)\n Some([1, 2, 5])\n nothing\n nothing\n nothing These correspond to the  code.slotnames ; the first is the  #self#  argument and the second is the input array. The remaining local variables (e.g.,  s  and  a ), have not yet been assigned–-we've only built the frame, but we haven't yet begun to execute it. The static parameter,  T , is stored in  frame.framedata.sparams : julia> frame.framedata.sparams\n1-element Array{Any,1}:\n Int64 The  Expr(:static_parameter, 1)  statement refers to this value. The other main storage is for the generated SSA values: julia> frame.framedata.ssavalues\n16-element Array{Any,1}:\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef Since we haven't executed any statements yet, these are all undefined. The other main entity is the so-called  program counter , which just indicates the next statement to be executed: julia> frame.pc\n1 Let's try executing the first statement: julia> JuliaInterpreter.step_expr!(frame)\n2 This indicates that it ran statement 1 and is prepared to run statement 2. (It's worth noting that the first line included a  call  to  zero , so behind the scenes JuliaInterpreter created a new frame for  zero , executed all the statements, and then popped back to  frame .) Since the first statement is an assignment of a local variable, let's check the locals again: julia> frame.framedata.locals\n5-element Array{Union{Nothing, Some{Any}},1}:\n Some(summer)\n Some([1, 2, 5])\n Some(0)\n nothing\n nothing You can see that the entry corresponding to  s  has been initialized. The next statement just retrieves one of the slots (the input argument  A ) and stores it in an SSA value: julia> JuliaInterpreter.step_expr!(frame)\n3\n\njulia> frame.framedata.ssavalues\n16-element Array{Any,1}:\n #undef\n    [1, 2, 5]\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef One can easily continue this until execution completes, which is indicated when  step_expr!  returns  nothing . Alternatively, use the higher-level  JuliaInterpreter.finish!(frame)  to step through the entire frame, or  JuliaInterpreter.finish_and_return!(frame)  to also obtain the return value."},{"id":125,"pagetitle":"Internals","title":"More complex expressions","ref":"/debug/stable/internals/#More-complex-expressions","content":" More complex expressions Sometimes you might have a whole sequence of expressions you want to run. In such cases, your first thought should be to construct the  Frame  manually. Here's a demonstration: using Test\n\nex = quote\n    x, y = 1, 2\n    @test x + y == 3\nend\n\nframe = Frame(Main, ex)\nJuliaInterpreter.finish_and_return!(frame)\n\n# output\n\nTest Passed\n  Expression: x + y == 3\n   Evaluated: 3 == 3"},{"id":126,"pagetitle":"Internals","title":"Toplevel code and world age","ref":"/debug/stable/internals/#Toplevel-code-and-world-age","content":" Toplevel code and world age Code that defines new  struct s, new methods, or new modules is a bit more complicated and requires special handling. In such cases, calling  finish_and_return!  on a frame that defines these new objects and then calls them can trigger a  world age error , in which the method is considered to be too new to be run by the currently compiled code. While one can resolve this by using  Base.invokelatest , we'd have to use that strategy throughout the entire package.  This would cause a major reduction in performance. To resolve this issue without leading to performance problems, care is required to return to \"top level\" after defining such objects. This leads to altered syntax for executing such expressions. Here's a demonstration of the problem: ex = :(map(x->x^2, [1, 2, 3]))\nframe = Frame(Main, ex)\njulia> JuliaInterpreter.finish_and_return!(frame)\nERROR: this frame needs to be run a top level The reason for this error becomes clearer if we examine  frame  or look directly at the lowered code: julia> Meta.lower(Main, ex)\n:($(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─      global var\"#3#4\"\n│        const var\"#3#4\"\n│   %3 = Core._structtype(Main, Symbol(\"#3#4\"), Core.svec(), Core.svec(), Core.svec(), false, 0)\n│        var\"#3#4\" = %3\n│        Core._setsuper!(var\"#3#4\", Core.Function)\n│        Core._typebody!(var\"#3#4\", Core.svec())\n└──      return nothing\n)))\n│   %2 = Core.svec(var\"#3#4\", Core.Any)\n│   %3 = Core.svec()\n│   %4 = Core.svec(%2, %3, $(QuoteNode(:(#= REPL[18]:1 =#))))\n│        $(Expr(:method, false, :(%4), CodeInfo(\n    @ REPL[18]:1 within `none`\n1 ─ %1 = Core.apply_type(Base.Val, 2)\n│   %2 = (%1)()\n│   %3 = Base.literal_pow(^, x, %2)\n└──      return %3\n)))\n│        #3 = %new(var\"#3#4\")\n│   %7 = #3\n│   %8 = Base.vect(1, 2, 3)\n│   %9 = map(%7, %8)\n└──      return %9\n)))) All of the code before the  %7  line is devoted to defining the anonymous function  x->x^2 : it creates a new \"anonymous type\" (here written as  var\"#3#4\" ), and then defines a \"call function\" for this type, equivalent to  (var\"#3#4\")(x) = x^2 . In some cases one can fix this simply by indicating that we want to run this frame at top level: julia> JuliaInterpreter.finish_and_return!(frame, true)\n3-element Array{Int64,1}:\n 1\n 4\n 9 In other cases, such as nested calls of new methods, you may need to allow the world age to update between evaluations. In such cases you want to use  ExprSplitter : for (mod, e) in ExprSplitter(Main, ex)\n    frame = Frame(mod, e)\n    while true\n        JuliaInterpreter.through_methoddef_or_done!(frame) === nothing && break\n    end\n    JuliaInterpreter.get_return(frame)\nend This splits the expression into a sequence of frames (here just one, but more complex blocks may be split up into many). Then, each frame is executed until it finishes defining a new method, then returns to top level. The return to top level causes an update in the world age. If the frame hasn't been finished yet (if the return value wasn't  nothing ), this continues executing where it left off. (Incidentally,  JuliaInterpreter.enter_call(map, x->x^2, [1, 2, 3])  works fine on its own, because the anonymous function is defined by the caller–-you'll see that the created frame is very simple.)"},{"id":131,"pagetitle":"Infiltrator.jl","title":"Infiltrator.jl","ref":"/inf/stable/#Infiltrator.jl","content":" Infiltrator.jl This packages provides the  @infiltrate  macro, which acts as a breakpoint with neglible runtime performance overhead. Note that you cannot access other function scopes or step into further calls. Use an actual debugger if you need that level of flexibility. Running code that ends up triggering the  @infiltrate  REPL mode via inline evaluation in VS Code or Juno can cause issues, so it's recommended to always use the REPL directly."},{"id":132,"pagetitle":"Infiltrator.jl","title":"@infiltrate","ref":"/inf/stable/#@infiltrate","content":" @infiltrate @infiltrate cond = true @infiltrate  sets an infiltration point. When the infiltration point is hit, it will drop you into an interactive REPL session that lets you inspect local variables and the call stack as well as execute aribtrary statements in the context of the current local and global scope. The optional argument  cond  only enables this infiltration point if it evaluates to  true . You can also use if isdefined(Main, :Infiltrator)\n  Main.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\nend to infiltrate package code without any post-hoc evaluation into the module (because the functional form does not require Infiltrator to be loaded at compiletime)."},{"id":133,"pagetitle":"Infiltrator.jl","title":"@exfiltrate","ref":"/inf/stable/#@exfiltrate","content":" @exfiltrate @exfiltrate Assigns all local variables into global storage."},{"id":134,"pagetitle":"Infiltrator.jl","title":"The safehouse","ref":"/inf/stable/#The-safehouse","content":" The safehouse Exfiltrating variables (with  @exfiltrate  or by assignment in an  @infiltrate  session) happens by assigning the variable to a global storage space (backed by a module); any exfiltrated objects can be directly accessed, via  Infiltrator.store  or its exported aliases  safehouse  or  exfiltrated : julia> foo(x) = @exfiltrate\nfoo (generic function with 1 method)\n\njulia> foo(3)\n\njulia> safehouse.x # or exfiltrated.x\n3 You can reset the safehouse with  Infiltrator.clear_store!() . You can also assign a specific module with  Infiltrator.set_store!(mod) . This allows you to e.g. set the backing module to  Main  and therefore export the contents of the safehouse to the global namespace (although doing so is not recommended)."},{"id":135,"pagetitle":"Infiltrator.jl","title":"Example usage","ref":"/inf/stable/#Example-usage","content":" Example usage julia> function f(x)\n         out = []\n         for i in x\n           push!(out, 2i)\n           @infiltrate\n         end\n         out\n       end\nf (generic function with 1 method)\n\njulia> f([1,2,3])\nInfiltrating f(x::Vector{Int64})\n  at REPL[10]:5\n\ninfil> ?\n  Code entered here is evaluated in the current scope. Changes to local variables are not possible; global variables can only be changed with eval/@eval.\n\n  All assignments will end up in the safehouse.\n\n  The following commands are special cased:\n\n    •  ?: Print this help text.\n\n    •  @trace: Print the current stack trace.\n\n    •  @locals: Print local variables. @locals x y only prints x and y.\n\n    •  @exfiltrate: Save all local variables into the store. @exfiltrate x y saves x and y; this variant can also exfiltrate variables defined in the infil> REPL.\n\n    •  @toggle: Toggle infiltrating at this @infiltrate spot (clear all with Infiltrator.clear_disabled!()).\n\n    •  @continue: Continue to the next infiltration point or exit (shortcut: Ctrl-D).\n\n    •  @doc symbol: Get help for symbol (same as in the normal Julia REPL).\n\n    •  @exit: Stop infiltrating for the remainder of this session and exit (on Julia versions prior to 1.5 this needs to be manually cleared with Infiltrator.end_session!()).\n\ninfil> @locals\n- out::Vector{Any} = Any[2]\n- i::Int64 = 1\n- x::Vector{Int64} = [1, 2, 3]\n\ninfil> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n [1] __throw_rational_argerror_zero(T::Type)\n   @ Base ./rational.jl:32\n [2] Rational{Int64}(num::Int64, den::Int64)\n   @ Base ./rational.jl:34\n [3] Rational\n   @ ./rational.jl:39 [inlined]\n [4] //(n::Int64, d::Int64)\n   @ Base ./rational.jl:62\n [5] top-level scope\n   @ none:1\n\ninfil> @toggle\nDisabled infiltration at this infiltration point.\n\ninfil> @toggle\nEnabled infiltration at this infiltration point.\n\ninfil> @continue\n\nInfiltrating f(x::Vector{Int64})\n  at REPL[10]:5\n\ninfil> intermediate = copy(out)\n2-element Vector{Any}:\n 2\n 4\n\ninfil> @exfiltrate intermediate x\nExfiltrating 2 local variables into the safehouse.\n\ninfil> @exit\n\n3-element Vector{Any}:\n 2\n 4\n 6\n\njulia> safehouse.intermediate\n2-element Vector{Any}:\n 2\n 4\n\njulia> @withstore begin\n         x = 23\n         x .* intermediate\n       end\n2-element Vector{Int64}:\n 46\n 92"},{"id":136,"pagetitle":"Infiltrator.jl","title":"Related projects","ref":"/inf/stable/#Related-projects","content":" Related projects @exfiltrate  for Python"},{"id":139,"pagetitle":"API","title":"API","ref":"/inf/stable/API/#API","content":" API"},{"id":140,"pagetitle":"API","title":"Infiltration and exfiltration","ref":"/inf/stable/API/#Infiltration-and-exfiltration","content":" Infiltration and exfiltration Add  @infiltrate  to any function to start the  infil>  REPL mode when that line runs. It's recommended to put Infiltrator.jl into your global environment and not into package environments for two reasons: Infiltrator.jl is intended as a development tool only and as such should not be shipped Any  @infiltrate  invocations in your package code will fail at compile-time, which prevents you from accidentally committing infiltrated code This means that you'll need to use  Revise.jl , inline evaluation in VS Code, or just plain old  @eval  to apply  @infiltrate  statements in your package code."},{"id":141,"pagetitle":"API","title":"Infiltrator.@infiltrate","ref":"/inf/stable/API/#Infiltrator.@infiltrate","content":" Infiltrator.@infiltrate  —  Macro @infiltrate cond = true @infiltrate  sets an infiltration point (or breakpoint). When the infiltration point is hit, it will drop you into an interactive REPL session that lets you inspect local variables and the call stack as well as execute aribtrary statements in the context of the current functions module. This macro also accepts an optional argument  cond  that must evaluate to a boolean, and then this macro will serve as a \"conditinal breakpoint\", which starts inspections only when its condition is  true . source"},{"id":142,"pagetitle":"API","title":"Infiltrator.infiltrate","ref":"/inf/stable/API/#Infiltrator.infiltrate","content":" Infiltrator.infiltrate  —  Function infiltrate(mod, locals, file, line) Function form of  @infiltrate . Use this to conditionally infiltrate package code without using e.g. Revise (because this version is valid during precompilation). This would typically be used as if isdefined(Main, :Infiltrator)\n  Main.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\nend source"},{"id":143,"pagetitle":"API","title":"Infiltrator.@exfiltrate","ref":"/inf/stable/API/#Infiltrator.@exfiltrate","content":" Infiltrator.@exfiltrate  —  Macro @exfiltrate Assigns all local variables into the global storage. source"},{"id":144,"pagetitle":"API","title":"The safehouse","ref":"/inf/stable/API/#The-safehouse","content":" The safehouse This is where all exfiltrated variables end up. You can either exfiltrate a variable explicitly with  @exfiltrate  or implicitly by assignment in the  infil>  REPL mode."},{"id":145,"pagetitle":"API","title":"Infiltrator.safehouse","ref":"/inf/stable/API/#Infiltrator.safehouse","content":" Infiltrator.safehouse  —  Constant safehouse\nexfiltrated\nInfiltrator.store Global storage for storing values while  @infiltrate ing or  @exfiltrate ing. Also see  clear_store! ,  set_store! , and  @withstore  for safehouse-related functionality. source"},{"id":146,"pagetitle":"API","title":"Infiltrator.clear_store!","ref":"/inf/stable/API/#Infiltrator.clear_store!","content":" Infiltrator.clear_store!  —  Function clear_store!(s = safehouse) Reset the store used for global symbols. source"},{"id":147,"pagetitle":"API","title":"Infiltrator.set_store!","ref":"/inf/stable/API/#Infiltrator.set_store!","content":" Infiltrator.set_store!  —  Function set_store!(s = safehouse, m::Module) Set the module backing the store  s . source"},{"id":148,"pagetitle":"API","title":"Infiltrator.@withstore","ref":"/inf/stable/API/#Infiltrator.@withstore","content":" Infiltrator.@withstore  —  Macro @withstore ex Evaluates the expression  ex  in the context of the global store. Mainly intended for interactive use, as changes to the store's state will not propagate into the returned expression. source"},{"id":149,"pagetitle":"API","title":"Utility","ref":"/inf/stable/API/#Utility","content":" Utility"},{"id":150,"pagetitle":"API","title":"Infiltrator.clear_disabled!","ref":"/inf/stable/API/#Infiltrator.clear_disabled!","content":" Infiltrator.clear_disabled!  —  Function clear_disabled!(s = safehouse) Clear all disabled infiltration points. source"},{"id":151,"pagetitle":"API","title":"Infiltrator.end_session!","ref":"/inf/stable/API/#Infiltrator.end_session!","content":" Infiltrator.end_session!  —  Function end_session!(s = safehouse) End this infiltration session (reverts the effect of  @exit  in the  debug>  REPL). Only needs to be manually called on Julia versions prior to 1.5. source"},{"id":152,"pagetitle":"API","title":"Infiltrator.toggle_async_check","ref":"/inf/stable/API/#Infiltrator.toggle_async_check","content":" Infiltrator.toggle_async_check  —  Function toggle_async_check(enabled) Enable or disable the check for safe REPL mode switching. May result in a non-functional REPL. source"},{"id":157,"pagetitle":"Home","title":"JuliaInterpreter","ref":"/debug/stable/#JuliaInterpreter","content":" JuliaInterpreter This package implements an  interpreter  for Julia code. Normally, Julia compiles your code when you first execute it; using JuliaInterpreter you can avoid compilation and execute the expressions that define your code directly. Interpreters have a number of applications, including support for stepping debuggers."},{"id":158,"pagetitle":"Home","title":"Use as an interpreter","ref":"/debug/stable/#Use-as-an-interpreter","content":" Use as an interpreter Using this package as an interpreter is straightforward: julia> using JuliaInterpreter\n\njulia> list = [1, 2, 5]\n3-element Vector{Int64}:\n 1\n 2\n 5\n\njulia> sum(list)\n8\n\njulia> @interpret sum(list)\n8"},{"id":159,"pagetitle":"Home","title":"Breakpoints","ref":"/debug/stable/#Breakpoints","content":" Breakpoints You can interrupt execution by setting breakpoints. You can set breakpoints via packages that explicitly target debugging, like  Juno ,  Debugger , and  Rebugger . But all of these just leverage the core functionality defined in JuliaInterpreter, so here we'll illustrate it without using any of these other packages. Let's set a conditional breakpoint, to be triggered any time one of the elements in the argument to  sum  is bigger than 4: julia> bp = @breakpoint sum([1, 2]) any(x->x>4, a); Note that in writing the condition, we used  a , the name of the argument to the relevant method of  sum . Conditionals should be written using a combination of argument and parameter names of the method into which you're inserting a breakpoint; you can also use any globally-available name (as used here with the  any  function). Now let's see what happens: julia> @interpret sum([1,2,3])  # no element bigger than 4, breakpoint should not trigger\n6\n\njulia> frame, bpref = @interpret sum([1,2,5])  # should trigger breakpoint\n(Frame for sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873\nc 1* 873  1 ─      nothing\n  2  873  │   %2 = ($(QuoteNode(NamedTuple)))()\n  3  873  │   %3 = Base.pairs(%2)\n⋮\na = [1, 2, 5], breakpoint(sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873, line 873)) frame  is described in more detail on the next page; for now, suffice it to say that the  c  in the leftmost column indicates the presence of a conditional breakpoint upon entry to  sum .  bpref  is a reference to the breakpoint of type  BreakpointRef . The breakpoint  bp  we created can be manipulated at the command line julia> disable(bp)\n\njulia> @interpret sum([1,2,5])\n8\n\njulia> enable(bp)\n\njulia> @interpret sum([1,2,5])\n(Frame for sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873\nc 1* 873  1 ─      nothing\n  2  873  │   %2 = ($(QuoteNode(NamedTuple)))()\n  3  873  │   %3 = Base.pairs(%2)\n⋮\na = [1, 2, 5], breakpoint(sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873, line 873)) disable  and  enable  allow you to turn breakpoints off and on without losing any conditional statements you may have provided;  remove  allows a permanent removal of the breakpoint. You can use  remove()  to remove all breakpoints in all methods. @breakpoint  allows you to optionally specify a line number at which the breakpoint is to be set. You can also use a functional form,  breakpoint , to specify file/line combinations or that you want to break on entry to  any  method of a particular function. At present, note that some of this functionality requires that you be running  Revise.jl . It is, in addition, possible to halt execution when otherwise an error would be thrown. This functionality is enabled using  break_on  and disabled with  break_off : julia> function f_outer()\n           println(\"before error\")\n           f_inner()\n           println(\"after error\")\n       end;\n\njulia> f_inner() = error(\"inner error\");\n\njulia> break_on(:error)\n\njulia> fr, pc = @interpret f_outer()\nbefore error\n(Frame for f_outer() in Main at none:1\n  1  2  1 ─      Base.println(\"before error\")\n  2* 3  │        f_inner()\n  3  4  │   %3 = Base.println(\"after error\")\n  4  4  └──      return %3\ncallee: f_inner() in Main at none:1, breakpoint(error(s::AbstractString) in Base at error.jl:33, line 33, ErrorException(\"inner error\")))\n\njulia> leaf(fr)\nFrame for error(s::AbstractString) in Base at error.jl:33\n  1  33  1 ─ %1 = ($(QuoteNode(ErrorException)))(s)\n  2* 33  │   %2 = Core.throw(%1)\n  3  33  └──      return %2\ns = \"inner error\"\ncaller: f_inner() in Main at none:1\n\njulia> typeof(pc)\nBreakpointRef\n\njulia> pc.err\nErrorException(\"inner error\")\n\njulia> break_off(:error)\n\njulia> @interpret f_outer()\nbefore error\nERROR: inner error\nStacktrace:\n[...] Finally, you can set breakpoints using  @bp : julia> function myfunction(x, y)\n           a = 1\n           b = 2\n           x > 3 && @bp\n           return a + b + x + y\n       end\nmyfunction (generic function with 1 method)\n\njulia> @interpret myfunction(1, 2)\n6\n\njulia> @interpret myfunction(5, 6)\n(Frame for myfunction(x, y) in Main at none:1\n⋮\n  3  4  │   %3 = x > 3\n  4  4  └──      goto #3 if not %3\nb 5* 4  2 ─      nothing\n  6  4  └──      goto #3\n  7  5  3 ┄ %7 = a + b + x + y\n⋮\nx = 5\ny = 6\nb = 2\na = 1, breakpoint(myfunction(x, y) in Main at none:1, line 4)) Here the breakpoint is marked with a  b  indicating that it is an unconditional breakpoint. Because we placed it inside the condition  x > 3 , we've achieved a conditional outcome. When using  @bp  in source-code files, the use of Revise is recommended, since it allows you to add breakpoints, test code, and then remove the breakpoints from the code without restarting Julia."},{"id":160,"pagetitle":"Home","title":"debug_command","ref":"/debug/stable/#debug_command","content":" debug_command You can control execution of frames via  debug_command . Authors of debugging applications should target  debug_command  for their interaction with JuliaInterpreter."},{"id":161,"pagetitle":"Home","title":"Hooks","ref":"/debug/stable/#Hooks","content":" Hooks Consider if you were building a debugging application with a GUI component which displays a dot in the text editor margin where a breakpoint is. If a user creates a breakpoint not via your GUI, but rather via a command in the REPL etc. then you still wish to keep your GUI up to date. How to do this? The answer is hooks. JuliaInterpreter has experimental support for having  a hook, or callback function invoked whenever the set of all breakpoints is changed. Hook functions are setup by invoking the  JuliaInterpreter.on_breakpoints_updated  function. To return to our example of keeping GUI up to date, the hooks would look something like this: using JuliaInterpreter\nusing JuliaInterpreter: AbstractBreakpoint, update_states!, on_breakpoints_updated\n\nbreakpoint_gui_elements = Dict{AbstractBreakpoint, MarginDot}()\n# ...\nfunction breakpoint_gui_hook(::typeof(breakpoint), bp::AbstractBreakpoint)\n    bp_dot = MarginDot(bp)\n    draw(bp_dot)\n    breakpoint_gui_elements[bp] = bp_dot\nend\n\nfunction breakpoint_gui_hook(::typeof(remove), bp::AbstractBreakpoint)\n    bp_dot = pop!(breakpoint_gui_elements, bp)\n    undraw(bp_dot)\nend\n\nfunction breakpoint_gui_hook(::typeof(update_states!), bp::AbstractBreakpoint)\n    is_enabled = bp.enabled[]\n    bp_dot = breakpoint_gui_elements[bp]\n    set_fill!(bp_dot, is_enabled ? :blue : :grey)\nend\n\non_breakpoints_updated(breakpoint_gui_hook)"},{"id":164,"pagetitle":"Lowered representation","title":"Lowered representation","ref":"/debug/stable/ast/#Lowered-representation","content":" Lowered representation JuliaInterpreter uses the lowered representation of code. The key advantage of lowered representation is that it is fairly well circumscribed: There are only a limited number of legal statements that can appear in lowered code Each statement is \"unpacked\" to essentially do one thing Scoping of variables is simplified via the slot mechanism, described below Names are fully resolved by module Macros are expanded Julia AST  describes the kinds of objects that can appear in lowered code. Let's start with a demonstration on a simple function: function summer(A::AbstractArray{T}) where T\n    s = zero(T)\n    for a in A\n        s += a\n    end\n    return s\nend\n\nA = [1, 2, 5] To interpret lowered representation, it maybe be useful to rewrite the body of  summer  in the following ways. First let's use an intermediate representation that expands the  for a in A ... end  loop:     s = zero(T)\n    temp = iterate(A)         # `for` loops get lowered to `iterate/while` loops\n    while temp !== nothing\n        a, state = temp\n        s += a\n        temp = iterate(A, state)\n    end\n    return s The lowered code takes the additional step of resolving the names by module and turning all the branching into  @goto/@label  equivalents:     # Code starting at line 2 (the first line of the body)\n    s = Main.zero(T)       # T corresponds to the first parameter, i.e., $(Expr(:static_parameter, 1))\n\n    # Code starting at line 3\n    temp = Base.iterate(A) # here temp = @_4\n    if temp === nothing    # this comparison gets stored as %4, and %5 stores !(temp===nothing)\n        @goto block4\n    end\n\n    @label block2\n        ## BEGIN block2\n        a, state = temp[1], temp[2]  # these correspond to the `getfield` calls, state is %9\n\n        # Code starting at line 4\n        s = s + a\n\n        # Code starting at line 5\n        temp = iterate(A, state)     # A is also %2\n        if temp === nothing\n            @goto block4             # the `while` condition was false\n        end\n        ## END block2\n\n    @goto block2           # here the `while` condition is still true\n\n    # Code starting at line 6\n    @label block4\n        ## BEGIN block4\n        return s\n        ## END block4 This has very close correspondence to the lowered representation: julia> code = @code_lowered debuginfo=:source summer(A)\nCodeInfo(\n    @ REPL[1]:2 within `summer'\n1 ─       s = Main.zero($(Expr(:static_parameter, 1)))\n│   @ REPL[1]:3 within `summer'\n│   %2  = A\n│         @_4 = Base.iterate(%2)\n│   %4  = @_4 === nothing\n│   %5  = Base.not_int(%4)\n└──       goto #4 if not %5\n2 ┄ %7  = @_4\n│         a = Core.getfield(%7, 1)\n│   %9  = Core.getfield(%7, 2)\n│   @ REPL[1]:4 within `summer'\n│         s = s + a\n│         @_4 = Base.iterate(%2, %9)\n│   %12 = @_4 === nothing\n│   %13 = Base.not_int(%12)\n└──       goto #4 if not %13\n3 ─       goto #2\n    @ REPL[1]:6 within `summer'\n4 ┄       return s\n) Note Not all Julia versions support  debuginfo . If the command above fails for you, just omit the  debuginfo=:source  portion. To understand this package's internals, you need to familiarize yourself with these  CodeInfo  objects. The lines that start with  @ REPL[1]:n  indicate the source line of the succeeding block of statements; here we defined this method in the REPL, so the source file is  REPL[1] ; the number after the colon is the line number. The numbers on the left correspond to  basic blocks , as we annotated with  @label block2  above. When used in statements these are printed with a hash, e.g., in  goto #4 if not %5 , the  #4  refers to basic block 4. The numbers in the next column–e.g.,  %2 , refer to  single static assignment (SSA) values . Each statement (each line of this printout) corresponds to a single SSA value, but only those used later in the code are printed using assignment syntax. Wherever a previous SSA value is used, it's referenced by an  SSAValue  and printed as  %5 ; for example, in  goto #4 if not %5 , the  %5  is the result of evaluating the 5th statement, which is  (Base.not_int)(%4) , which in turn refers to the result of statement 4. Finally, temporary variables here are shown as  @_4 ; the  _  indicates a  slot , either one of the input arguments or a local variable, and the 4 means the 4th one. Together lines 4 and 5 correspond to  !(@_4 === nothing) , where  @_4  has been assigned the result of the call to  iterate  occurring on line 3. (In some Julia versions, this may be printed as  #temp# , similar to how we named it in our alternative implementation above.) Let's look at a couple of the fields of the  CodeInfo . First, the statements themselves: julia> code.code\n16-element Array{Any,1}:\n :(_3 = Main.zero($(Expr(:static_parameter, 1))))\n :(_2)\n :(_4 = Base.iterate(%2))\n :(_4 === nothing)\n :(Base.not_int(%4))\n :(unless %5 goto %16)\n :(_4)\n :(_5 = Core.getfield(%7, 1))\n :(Core.getfield(%7, 2))\n :(_3 = _3 + _5)\n :(_4 = Base.iterate(%2, %9))\n :(_4 === nothing)\n :(Base.not_int(%12))\n :(unless %13 goto %16)\n :(goto %7)\n :(return _3) You can see directly that the SSA assignments are implicit; they are not directly present in the statement list. The most noteworthy change here is the appearance of more objects like  _3 , which are references that index into local variable slots: julia> code.slotnames\n5-element Array{Any,1}:\n Symbol(\"#self#\")\n :A\n :s\n Symbol(\"\")\n :a When printing the whole  CodeInfo  object, these  slotnames  are substituted in (unless they are empty, as was the case for  @_4  above)."},{"id":167,"pagetitle":"Function reference","title":"Function reference","ref":"/debug/stable/dev_reference/#Function-reference","content":" Function reference"},{"id":168,"pagetitle":"Function reference","title":"Running the interpreter","ref":"/debug/stable/dev_reference/#Running-the-interpreter","content":" Running the interpreter"},{"id":169,"pagetitle":"Function reference","title":"JuliaInterpreter.@interpret","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@interpret","content":" JuliaInterpreter.@interpret  —  Macro @interpret f(args; kwargs...) Evaluate  f  on the specified arguments using the interpreter. Example julia> a = [1, 7]\n2-element Vector{Int64}:\n 1\n 7\n\njulia> sum(a)\n8\n\njulia> @interpret sum(a)\n8 source"},{"id":170,"pagetitle":"Function reference","title":"Frame creation","ref":"/debug/stable/dev_reference/#Frame-creation","content":" Frame creation"},{"id":171,"pagetitle":"Function reference","title":"JuliaInterpreter.Frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Frame-Tuple{Module, Expr}","content":" JuliaInterpreter.Frame  —  Method frame = Frame(mod::Module, ex::Expr) Construct a  Frame  to evaluate  ex  in module  mod . This constructor can error, for example if lowering  ex  results in an  :error  or  :incomplete  expression, or if it otherwise fails to return a  :thunk . source"},{"id":172,"pagetitle":"Function reference","title":"JuliaInterpreter.ExprSplitter","ref":"/debug/stable/dev_reference/#JuliaInterpreter.ExprSplitter","content":" JuliaInterpreter.ExprSplitter  —  Type ExprSplitter(mod::Module, ex::Expr; lnn=nothing) Create an iterable that returns individual expressions together with their module of evaluation. Optionally supply an initial  LineNumberNode lnn . Example julia> expr = quote\n           public(x::Integer) = true\n           module Private\n           private(y::String) = false\n           end\n           const threshold = 0.1\n       end;\n\njulia> for (mod, ex) in ExprSplitter(Main, expr)\n           @show mod ex\n       end\nmod = Main\nex = quote\n    #= REPL[7]:2 =#\n    public(x::Integer) = begin\n            #= REPL[7]:2 =#\n            true\n        end\nend\nmod = Main.Private\nex = quote\n    #= REPL[7]:4 =#\n    private(y::String) = begin\n            #= REPL[7]:4 =#\n            false\n        end\nend\nmod = Main\nex = :($(Expr(:toplevel, :(()), :(const threshold = 0.1)))) Note that  Main.Private  was created for you so that its internal expressions could be evaluated.  ExprSplitter  will check to see whether the module already exists and if so return it rather than try to create a new module with the same name. In general each returned expression is a block with two parts: a  LineNumberNode  followed by a single expression. In some cases the returned expression may be  :toplevel , as shown in the  const  declaration, but otherwise it will be a  :block . World age, frame creation, and evaluation The primary purpose of  ExprSplitter  is to allow sequential return to top-level (e.g., the REPL) after evaluation of each expression. Returning to top-level allows the world age to update, and hence allows one to call methods and use types defined in earlier expressions in a block. For evaluation by JuliaInterpreter, the returned module/expression pairs can be passed directly to the  Frame  constructor. However, some expressions cannot be converted into  Frame s and may need special handling: julia> for (mod, ex) in ExprSplitter(Main, expr)\n           if ex.head === :global\n               # global declarations can't be lowered to a CodeInfo.\n               # In this demo we choose to evaluate them, but you can do something else.\n               Core.eval(mod, ex)\n               continue\n           end\n           frame = Frame(mod, ex)\n           debug_command(frame, :c, true)\n       end\n\njulia> threshold\n0.1\n\njulia> public(3)\ntrue If you're parsing package code,  ex  might be a docstring-expression; you may wish to check for such expressions and take distinct actions. See  Frame(mod::Module, ex::Expr)  for more information about frame creation. source"},{"id":173,"pagetitle":"Function reference","title":"JuliaInterpreter.enter_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enter_call","content":" JuliaInterpreter.enter_call  —  Function frame = enter_call(f, args...; kwargs...) Build a  Frame  ready to execute  f  with the specified positional and keyword arguments. Example julia> mymethod(x) = x+1\nmymethod (generic function with 1 method)\n\njulia> JuliaInterpreter.enter_call(mymethod, 1)\nFrame for mymethod(x) in Main at none:1\n  1* 1  1 ─ %1 = x + 1\n  2  1  └──      return %1\nx = 1\n\njulia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 2 methods)\n\njulia> JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])\nFrame for mymethod(x::Vector{T}) where T in Main at none:1\n  1* 1  1 ─     return 1\nx = [1.0, 2.0]\nT = Float64 For a  @generated  function you can use  enter_call((f, true), args...; kwargs...)  to execute the generator of a  @generated  function, rather than the code that would be created by the generator. See  enter_call_expr  for a similar approach based on expressions. source"},{"id":174,"pagetitle":"Function reference","title":"JuliaInterpreter.enter_call_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enter_call_expr","content":" JuliaInterpreter.enter_call_expr  —  Function frame = enter_call_expr(expr; enter_generated=false) Build a  Frame  ready to execute the expression  expr . Set  enter_generated=true  if you want to execute the generator of a  @generated  function, rather than the code that would be created by the generator. Example julia> mymethod(x) = x+1\nmymethod (generic function with 1 method)\n\njulia> JuliaInterpreter.enter_call_expr(:($mymethod(1)))\nFrame for mymethod(x) in Main at none:1\n  1* 1  1 ─ %1 = x + 1\n  2  1  └──      return %1\nx = 1\n\njulia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 2 methods)\n\njulia> a = [1.0, 2.0]\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> JuliaInterpreter.enter_call_expr(:($mymethod($a)))\nFrame for mymethod(x::Vector{T}) where T in Main at none:1\n  1* 1  1 ─     return 1\nx = [1.0, 2.0]\nT = Float64 See  enter_call  for a similar approach not based on expressions. source"},{"id":175,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_frame","content":" JuliaInterpreter.prepare_frame  —  Function frame = prepare_frame(framecode::FrameCode, frameargs, lenv) Construct a new  Frame  for  framecode , given lowered-code arguments  frameargs  and static parameters  lenv . See  JuliaInterpreter.prepare_call  for information about how to prepare the inputs. source"},{"id":176,"pagetitle":"Function reference","title":"JuliaInterpreter.determine_method_for_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.determine_method_for_expr","content":" JuliaInterpreter.determine_method_for_expr  —  Function framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false) Prepare all the information needed to execute a particular  :call  expression  expr . For example, try  JuliaInterpreter.determine_method_for_expr(:($sum([1,2]))) . See  JuliaInterpreter.prepare_call  for information about the outputs. source"},{"id":177,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_args","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_args","content":" JuliaInterpreter.prepare_args  —  Function frun, allargs = prepare_args(fcall, fargs, kwargs) Prepare the complete argument sequence for a call to  fcall .  fargs = [fcall, args...]  is a list containing both  fcall  (the  #self#  slot in lowered code) and the positional arguments supplied to  fcall .  kwargs  is a list of keyword arguments, supplied either as list of expressions  :(kwname=kwval)  or pairs  :kwname=>kwval . For non-keyword methods,  frun === fcall , but for methods with keywords  frun  will be the keyword-sorter function for  fcall . Example julia> mymethod(x) = 1\nmymethod (generic function with 1 method)\n\njulia> mymethod(x, y; verbose=false) = nothing\nmymethod (generic function with 2 methods)\n\njulia> JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())\n(mymethod, Any[mymethod, 15])\n\njulia> JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=>true])\n(var\"#mymethod##kw\"(), Any[var\"#mymethod##kw\"(), (verbose = true,), mymethod, 1, 2]) source"},{"id":178,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_call","content":" JuliaInterpreter.prepare_call  —  Function framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false) Prepare all the information needed to execute lowered code for  f  given arguments  allargs .  f  and  allargs  are the outputs of  prepare_args . For  @generated  methods, set  enter_generated=true  if you want to extract the lowered code of the generator itself. On return  framecode  is the  FrameCode  of the method.  frameargs  contains the actual arguments needed for executing this frame (for generators, this will be the types of  allargs );  lenv  is the \"environment\", i.e., the static parameters for  f  given  allargs .  argtypes  is the  Tuple -type for this specific call (equivalent to the signature of the  MethodInstance ). Example julia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 1 method)\n\njulia> framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);\n\njulia> framecode\n  1  1  1 ─     return 1\n\njulia> frameargs\n2-element Vector{Any}:\n mymethod (generic function with 1 method)\n [1.0, 2.0]\n\njulia> lenv\nsvec(Float64)\n\njulia> argtypes\nTuple{typeof(mymethod), Vector{Float64}} source"},{"id":179,"pagetitle":"Function reference","title":"JuliaInterpreter.get_call_framecode","ref":"/debug/stable/dev_reference/#JuliaInterpreter.get_call_framecode","content":" JuliaInterpreter.get_call_framecode  —  Function framecode, lenv = get_call_framecode(fargs, parentframe::FrameCode, idx::Int) Return the framecode and environment for a call specified by  fargs = [f, args...]  (see  prepare_args ).  parentframecode  is the caller, and  idx  is the program-counter index. If possible,  framecode  will be looked up from the local method tables of  parentframe . source"},{"id":180,"pagetitle":"Function reference","title":"JuliaInterpreter.optimize!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.optimize!","content":" JuliaInterpreter.optimize!  —  Function optimize!(code::CodeInfo, mod::Module) Perform minor optimizations on the lowered AST in  code  to reduce execution time of the interpreter. Currently it looks up  GlobalRef s (for which it needs  mod  to know the scope in which this will run) and ensures that no statement includes nested  :call  expressions (splitting them out into multiple SSA-form statements if needed). source"},{"id":181,"pagetitle":"Function reference","title":"Frame traversal","ref":"/debug/stable/dev_reference/#Frame-traversal","content":" Frame traversal"},{"id":182,"pagetitle":"Function reference","title":"JuliaInterpreter.root","ref":"/debug/stable/dev_reference/#JuliaInterpreter.root","content":" JuliaInterpreter.root  —  Function rframe = root(frame) Return the initial frame in the call stack. source"},{"id":183,"pagetitle":"Function reference","title":"JuliaInterpreter.leaf","ref":"/debug/stable/dev_reference/#JuliaInterpreter.leaf","content":" JuliaInterpreter.leaf  —  Function lframe = leaf(frame) Return the deepest callee in the call stack. source"},{"id":184,"pagetitle":"Function reference","title":"Frame execution","ref":"/debug/stable/dev_reference/#Frame-execution","content":" Frame execution"},{"id":185,"pagetitle":"Function reference","title":"JuliaInterpreter.Compiled","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Compiled","content":" JuliaInterpreter.Compiled  —  Type Compiled  is a trait indicating that any  :call  expressions should be evaluated using Julia's normal compiled-code evaluation. The alternative is to pass  stack=Frame[] , which will cause all calls to be evaluated via the interpreter. source"},{"id":186,"pagetitle":"Function reference","title":"JuliaInterpreter.step_expr!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.step_expr!","content":" JuliaInterpreter.step_expr!  —  Function pc = step_expr!(recurse, frame, istoplevel=false)\npc = step_expr!(frame, istoplevel=false) Execute the next statement in  frame .  pc  is the new program counter, or  nothing  if execution terminates, or a  BreakpointRef  if execution hits a breakpoint. recurse  controls call evaluation;  recurse = Compiled()  evaluates :call expressions by normal dispatch. The default value  recurse = finish_and_return!  will use recursive interpretation. If you are evaluating  frame  at module scope you should pass  istoplevel=true . source"},{"id":187,"pagetitle":"Function reference","title":"JuliaInterpreter.finish!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish!","content":" JuliaInterpreter.finish!  —  Function pc = finish!(recurse, frame, istoplevel=false)\npc = finish!(frame, istoplevel=false) Run  frame  until execution terminates.  pc  is either  nothing  (if execution terminates when it hits a  return  statement) or a reference to a breakpoint. In the latter case,  leaf(frame)  returns the frame in which it hit the breakpoint. recurse  controls call evaluation;  recurse = Compiled()  evaluates :call expressions by normal dispatch, whereas the default  recurse = finish_and_return!  uses recursive interpretation. source"},{"id":188,"pagetitle":"Function reference","title":"JuliaInterpreter.finish_and_return!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish_and_return!","content":" JuliaInterpreter.finish_and_return!  —  Function ret = finish_and_return!(recurse, frame, istoplevel::Bool=false)\nret = finish_and_return!(frame, istoplevel::Bool=false) Call  JuliaInterpreter.finish!  and pass back the return value  ret . If execution pauses at a breakpoint,  ret  is the reference to the breakpoint. source"},{"id":189,"pagetitle":"Function reference","title":"JuliaInterpreter.finish_stack!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish_stack!","content":" JuliaInterpreter.finish_stack!  —  Function ret = finish_stack!(recurse, frame, rootistoplevel=false)\nret = finish_stack!(frame, rootistoplevel=false) Unwind the callees of  frame , finishing each before returning to the caller.  frame  itself is also finished.  rootistoplevel  should be true if the root frame is top-level. ret  is typically the returned value. If execution hits a breakpoint,  ret  will be a reference to the breakpoint. source"},{"id":190,"pagetitle":"Function reference","title":"JuliaInterpreter.get_return","ref":"/debug/stable/dev_reference/#JuliaInterpreter.get_return","content":" JuliaInterpreter.get_return  —  Function ret = get_return(frame) Get the return value of  frame . Throws an error if  frame.pc  does not point to a  return  expression.  frame  must have already been executed so that the return value has been computed (see, e.g.,  JuliaInterpreter.finish! ). source"},{"id":191,"pagetitle":"Function reference","title":"JuliaInterpreter.next_until!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_until!","content":" JuliaInterpreter.next_until!  —  Function pc = next_until!(predicate, recurse, frame, istoplevel=false)\npc = next_until!(predicate, frame, istoplevel=false) Execute the current statement. Then step through statements of  frame  until the next statement satisfies  predicate(frame) .  pc  will be the index of the statement at which evaluation terminates,  nothing  (if the frame reached a  return ), or a  BreakpointRef . source"},{"id":192,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_next_until!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_next_until!","content":" JuliaInterpreter.maybe_next_until!  —  Function pc = maybe_next_until!(predicate, recurse, frame, istoplevel=false)\npc = maybe_next_until!(predicate, frame, istoplevel=false) Like  next_until!  except checks  predicate  before executing the current statment. source"},{"id":193,"pagetitle":"Function reference","title":"JuliaInterpreter.through_methoddef_or_done!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.through_methoddef_or_done!","content":" JuliaInterpreter.through_methoddef_or_done!  —  Function pc = through_methoddef_or_done!(recurse, frame)\npc = through_methoddef_or_done!(frame) Runs  frame  at top level until it either finishes (e.g., hits a  return  statement) or defines a new method. source"},{"id":194,"pagetitle":"Function reference","title":"JuliaInterpreter.evaluate_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.evaluate_call!","content":" JuliaInterpreter.evaluate_call!  —  Function ret = evaluate_call!(Compiled(), frame::Frame, call_expr)\nret = evaluate_call!(recurse,    frame::Frame, call_expr) Evaluate a  :call  expression  call_expr  in the context of  frame . The first causes it to be executed using Julia's normal dispatch (compiled code), whereas the second recurses in via the interpreter.  recurse  has a default value of  JuliaInterpreter.finish_and_return! . source"},{"id":195,"pagetitle":"Function reference","title":"JuliaInterpreter.evaluate_foreigncall","ref":"/debug/stable/dev_reference/#JuliaInterpreter.evaluate_foreigncall","content":" JuliaInterpreter.evaluate_foreigncall  —  Function ret = evaluate_foreigncall(recurse, frame::Frame, call_expr) Evaluate a  :foreigncall  (from a  ccall ) statement  callexpr  in the context of  frame . source"},{"id":196,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_evaluate_builtin","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_evaluate_builtin","content":" JuliaInterpreter.maybe_evaluate_builtin  —  Function ret = maybe_evaluate_builtin(frame, call_expr, expand::Bool) If  call_expr  is to a builtin function, evaluate it, returning the result inside a  Some  wrapper. Otherwise, return  call_expr . If  expand  is true,  Core._apply_iterate  calls will be resolved as a call to the applied function. source"},{"id":197,"pagetitle":"Function reference","title":"JuliaInterpreter.next_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_call!","content":" JuliaInterpreter.next_call!  —  Function pc = next_call!(recurse, frame, istoplevel=false)\npc = next_call!(frame, istoplevel=false) Execute the current statement. Continue stepping through  frame  until the next  :return  or  :call  expression. source"},{"id":198,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_next_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_next_call!","content":" JuliaInterpreter.maybe_next_call!  —  Function pc = maybe_next_call!(recurse, frame, istoplevel=false)\npc = maybe_next_call!(frame, istoplevel=false) Return the current program counter of  frame  if it is a  :return  or  :call  expression. Otherwise, step through the statements of  frame  until the next  :return  or  :call  expression. source"},{"id":199,"pagetitle":"Function reference","title":"JuliaInterpreter.next_line!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_line!","content":" JuliaInterpreter.next_line!  —  Function pc = next_line!(recurse, frame, istoplevel=false)\npc = next_line!(frame, istoplevel=false) Execute until reaching the first call of the next line of the source code. Upon return,  pc  is either the new program counter,  nothing  if a  return  is reached, or a  BreakpointRef  if it encountered a wrapper call. In the latter case, call  leaf(frame)  to obtain the new execution frame. source"},{"id":200,"pagetitle":"Function reference","title":"JuliaInterpreter.until_line!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.until_line!","content":" JuliaInterpreter.until_line!  —  Function pc = until_line!(recurse, frame, line=nothing istoplevel=false)\npc = until_line!(frame, line=nothing, istoplevel=false) Execute until the current frame reaches a line greater than  line . If  line == nothing  execute until the current frame reaches any line greater than the current line. source"},{"id":201,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_reset_frame!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_reset_frame!","content":" JuliaInterpreter.maybe_reset_frame!  —  Function ret = maybe_reset_frame!(recurse, frame, pc, rootistoplevel) Perform a return to the caller, or descend to the level of a breakpoint.  pc  is the return state from the previous command (e.g.,  next_call!  or similar).  rootistoplevel  should be true if the root frame is top-level. ret  will be  nothing  if we have just completed a top-level frame. Otherwise, cframe, cpc = ret where  cframe  is the frame from which execution should continue and  cpc  is the state of  cframe  (the program counter, a  BreakpointRef , or  nothing ). source"},{"id":202,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_step_through_wrapper!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_step_through_wrapper!","content":" JuliaInterpreter.maybe_step_through_wrapper!  —  Function cframe = maybe_step_through_wrapper!(recurse, frame)\ncframe = maybe_step_through_wrapper!(frame) Return the new frame of execution, potentially stepping through \"wrapper\" methods like those that supply default positional arguments or handle keywords.  cframe  is the leaf frame from which execution should start. source"},{"id":203,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_step_through_kwprep!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_step_through_kwprep!","content":" JuliaInterpreter.maybe_step_through_kwprep!  —  Function frame = maybe_step_through_kwprep!(recurse, frame)\nframe = maybe_step_through_kwprep!(frame) If  frame.pc  points to the beginning of preparatory work for calling a keyword-argument function, advance forward until the actual call. source"},{"id":204,"pagetitle":"Function reference","title":"JuliaInterpreter.handle_err","ref":"/debug/stable/dev_reference/#JuliaInterpreter.handle_err","content":" JuliaInterpreter.handle_err  —  Function loc = handle_err(recurse, frame, err) Deal with an error  err  that arose while evaluating  frame . There are one of three behaviors: if  frame  catches the error,  loc  is the program counter at which to resume evaluation of  frame ; if  frame  doesn't catch the error, but  break_on_error[]  is  true ,  loc  is a  BreakpointRef ; otherwise,  err  gets rethrown. source"},{"id":205,"pagetitle":"Function reference","title":"JuliaInterpreter.debug_command","ref":"/debug/stable/dev_reference/#JuliaInterpreter.debug_command","content":" JuliaInterpreter.debug_command  —  Function ret = debug_command(recurse, frame, cmd, rootistoplevel=false; line=nothing)\nret = debug_command(frame, cmd, rootistoplevel=false; line=nothing) Perform one \"debugger\" command. The keyword arguments are not used for all debug commands.  cmd  should be one of: :n : advance to the next line :s : step into the next call :sl  step into the last call on the current line (e.g. steps into  f  if the line is  f(g(h(x))) ). :until : advance the frame to line  line  if given, otherwise advance to the line after the current line :c : continue execution until termination or reaching a breakpoint :finish : finish the current frame and return to the parent or one of the 'advanced' commands :nc : step forward to the next call :se : execute a single statement :si : execute a single statement, stepping in if it's a call :sg : step into the generator of a generated function rootistoplevel  and  ret  are as described for  JuliaInterpreter.maybe_reset_frame! . source"},{"id":206,"pagetitle":"Function reference","title":"Breakpoints","ref":"/debug/stable/dev_reference/#Breakpoints","content":" Breakpoints"},{"id":207,"pagetitle":"Function reference","title":"JuliaInterpreter.@breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@breakpoint","content":" JuliaInterpreter.@breakpoint  —  Macro @breakpoint f(args...) condition=nothing\n@breakpoint f(args...) line condition=nothing Break upon entry, or at the specified line number, in the method called by  f(args...) . Optionally supply a condition expressed in terms of the arguments and internal variables of the method. If  line  is supplied, it must be a literal integer. Example Suppose a method  mysum  is defined as follows, where the numbers to the left are the line number in the file: 12 function mysum(A)\n13     s = zero(eltype(A))\n14     for a in A\n15         s += a\n16     end\n17     return s\n18 end Then @breakpoint mysum(A) 15 s>10 would cause execution of the loop to break whenever  s>10 . source"},{"id":208,"pagetitle":"Function reference","title":"JuliaInterpreter.@bp","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@bp","content":" JuliaInterpreter.@bp  —  Macro @bp Insert a breakpoint at a location in the source code. source"},{"id":209,"pagetitle":"Function reference","title":"JuliaInterpreter.breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.breakpoint","content":" JuliaInterpreter.breakpoint  —  Function breakpoint(f, [sig], [line], [condition]) Add a breakpoint to  f  with the specified argument types  sig .¨ If  sig  is not given, the breakpoint will apply to all methods of  f . If  f  is a method, the breakpoint will only apply to that method. Optionally specify an absolute line number  line  in the source file; the default is to break upon entry at the first line of the body. Without  condition , the breakpoint will be triggered every time it is encountered; the second only if  condition  evaluates to  true .  condition  should be written in terms of the arguments and local variables of  f . Example function radius2(x, y)\n    return x^2 + y^2\nend\n\nbreakpoint(radius2, Tuple{Int,Int}, :(y > x)) source breakpoint(file, line, [condition]) Set a breakpoint in  file  at  line . The argument  file  can be a filename, a partial path or absolute path. For example,  file = foo.jl  will match against all files with the name  foo.jl ,  file = src/foo.jl  will match against all paths containing  src/foo.jl , e.g. both  Foo/src/foo.jl  and  Bar/src/foo.jl . Absolute paths only matches against the file with that exact absolute path. source"},{"id":210,"pagetitle":"Function reference","title":"JuliaInterpreter.enable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enable","content":" JuliaInterpreter.enable  —  Function enable(bp::AbstractBreakpoint) Enable breakpoint  bp . source enable() Enable all breakpoints. source"},{"id":211,"pagetitle":"Function reference","title":"JuliaInterpreter.disable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.disable","content":" JuliaInterpreter.disable  —  Function disable(bp::AbstractBreakpoint) Disable breakpoint  bp . Disabled breakpoints can be re-enabled with  enable . source disable() Disable all breakpoints. source"},{"id":212,"pagetitle":"Function reference","title":"JuliaInterpreter.remove","ref":"/debug/stable/dev_reference/#JuliaInterpreter.remove","content":" JuliaInterpreter.remove  —  Function remove(bp::AbstractBreakpoint) Remove (delete) breakpoint  bp . Removed breakpoints cannot be re-enabled. source remove() Remove all breakpoints. source"},{"id":213,"pagetitle":"Function reference","title":"JuliaInterpreter.toggle","ref":"/debug/stable/dev_reference/#JuliaInterpreter.toggle","content":" JuliaInterpreter.toggle  —  Function toggle(bp::AbstractBreakpoint) Toggle breakpoint  bp . source"},{"id":214,"pagetitle":"Function reference","title":"JuliaInterpreter.break_on","ref":"/debug/stable/dev_reference/#JuliaInterpreter.break_on","content":" JuliaInterpreter.break_on  —  Function break_on(states...) Turn on automatic breakpoints when any of the conditions described in  states  occurs. The supported states are: :error : trigger a breakpoint any time an uncaught exception is thrown :throw  : trigger a breakpoint any time a throw is executed (even if it will eventually be caught) source"},{"id":215,"pagetitle":"Function reference","title":"JuliaInterpreter.break_off","ref":"/debug/stable/dev_reference/#JuliaInterpreter.break_off","content":" JuliaInterpreter.break_off  —  Function break_off(states...) Turn off automatic breakpoints when any of the conditions described in  states  occurs. See  break_on  for a description of valid states. source"},{"id":216,"pagetitle":"Function reference","title":"JuliaInterpreter.breakpoints","ref":"/debug/stable/dev_reference/#JuliaInterpreter.breakpoints","content":" JuliaInterpreter.breakpoints  —  Function breakpoints()::Vector{AbstractBreakpoint} Return an array with all breakpoints. source"},{"id":217,"pagetitle":"Function reference","title":"JuliaInterpreter.dummy_breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.dummy_breakpoint","content":" JuliaInterpreter.dummy_breakpoint  —  Function bpref = dummy_breakpoint(recurse, frame::Frame, istoplevel) Return a fake breakpoint.  dummy_breakpoint  can be useful as the  recurse  argument to  evaluate_call!  (or any of the higher-order commands) to ensure that you return immediately after stepping into a call. source"},{"id":218,"pagetitle":"Function reference","title":"Types","ref":"/debug/stable/dev_reference/#Types","content":" Types"},{"id":219,"pagetitle":"Function reference","title":"JuliaInterpreter.Frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Frame","content":" JuliaInterpreter.Frame  —  Type Frame  represents the current execution state in a particular call frame. Fields: framecode : the  FrameCode  for this frame. framedata : the  FrameData  for this frame. pc : the program counter (integer index of the next statment to be evaluated) for this frame. caller : the parent caller of this frame, or  nothing . callee : the frame called by this one, or  nothing . The  Base  functions  show_backtrace  and  display_error  are overloaded such that  show_backtrace(io::IO, frame::Frame)  and  display_error(io::IO, er, frame::Frame)  shows a backtrace or error, respectively, in a similar way as to how Base shows them. source"},{"id":220,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameCode","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameCode","content":" JuliaInterpreter.FrameCode  —  Type FrameCode  holds static information about a method or toplevel code. One  FrameCode  can be shared by many calling  Frame s. Important fields: scope : the  Method  or  Module  in which this frame is to be evaluated. src : the  CodeInfo  object storing (optimized) lowered source code. methodtables : a vector, each entry potentially stores a \"local method table\" for the corresponding  :call  expression in  src  (undefined entries correspond to statements that do not contain  :call  expressions). used : a  BitSet  storing the list of SSAValues that get referenced by later statements. source"},{"id":221,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameData","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameData","content":" JuliaInterpreter.FrameData  —  Type FrameData  holds the arguments, local variables, and intermediate execution state in a particular call frame. Important fields: locals : a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in the  slotnames  of the src. Use  locals  to extract the current value of local variables. ssavalues : a vector containing the  Static Single Assignment  values produced at the current state of execution. sparams : the static type parameters, e.g., for  f(x::Vector{T}) where T  this would store the value of  T  given the particular input  x . exception_frames : a list of indexes to  catch  blocks for handling exceptions within the current frame. The active handler is the last one on the list. last_exception : the exception  throw n by this frame or one of its callees. source"},{"id":222,"pagetitle":"Function reference","title":"JuliaInterpreter._INACTIVE_EXCEPTION","ref":"/debug/stable/dev_reference/#JuliaInterpreter._INACTIVE_EXCEPTION","content":" JuliaInterpreter._INACTIVE_EXCEPTION  —  Type _INACTIVE_EXCEPTION Represents a case where no exceptions are thrown yet. End users will not see this singleton type, otherwise it usually means there is missing error handling in the interpretation process. source"},{"id":223,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameInstance","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameInstance","content":" JuliaInterpreter.FrameInstance  —  Type FrameInstance  represents a method specialized for particular argument types. Fields: framecode : the  FrameCode  for the method. sparam_vals : the static parameter values for the method. source"},{"id":224,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointState","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointState","content":" JuliaInterpreter.BreakpointState  —  Type BreakpointState(isactive=true, condition=JuliaInterpreter.truecondition) BreakpointState  represents a breakpoint at a particular statement in a  FrameCode .  isactive  indicates whether the breakpoint is currently  enable d or  disable d.  condition  is a function that accepts a single  Frame , and  condition(frame)  must return either  true  or  false . Execution will stop at a breakpoint only if  isactive  and  condition(frame)  both evaluate as  true . The default  condition  always returns  true . To create these objects, see  breakpoint . source"},{"id":225,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointRef","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointRef","content":" JuliaInterpreter.BreakpointRef  —  Type BreakpointRef(framecode, stmtidx)\nBreakpointRef(framecode, stmtidx, err) A reference to a breakpoint at a particular statement index  stmtidx  in  framecode . If the break was due to an error, supply that as well. Commands that execute complex control-flow (e.g.,  next_line! ) may also return a  BreakpointRef  to indicate that the execution stack switched frames, even when no breakpoint has been set at the corresponding statement. source"},{"id":226,"pagetitle":"Function reference","title":"JuliaInterpreter.AbstractBreakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.AbstractBreakpoint","content":" JuliaInterpreter.AbstractBreakpoint  —  Type AbstractBreakpoint  is the abstract type that is the supertype for breakpoints. Currently, the concrete breakpoint types  BreakpointSignature  and  BreakpointFileLocation  exist. Common fields shared by the concrete breakpoints: condition::Union{Nothing,Expr,Tuple{Module,Expr}} : the condition when the breakpoint applies .  nothing  means unconditionally, otherwise when the  Expr  (optionally in  Module ). enabled::Ref{Bool} : If the breakpoint is enabled (should not be directly modified, use  enable()  or  disable() ). instances::Vector{BreakpointRef} : All the  BreakpointRef  that the breakpoint has applied to. line::Int  The line of the breakpoint (equal to 0 if unset). See  BreakpointSignature  and  BreakpointFileLocation  for additional fields in the concrete types. source"},{"id":227,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointSignature","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointSignature","content":" JuliaInterpreter.BreakpointSignature  —  Type A  BreakpointSignature  is a breakpoint that is set on methods or functions. Fields: f::Union{Method, Function, Type} : A method or function that the breakpoint should apply to. sig::Union{Nothing, Type} : if  f  is a  Method , always equal to  nothing . Otherwise, contains the method signature  as a tuple type for what methods the breakpoint should apply to. For common fields shared by all breakpoints, see  AbstractBreakpoint . source"},{"id":228,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointFileLocation","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointFileLocation","content":" JuliaInterpreter.BreakpointFileLocation  —  Type A  BreakpointFileLocation  is a breakpoint that is set on a line in a file. Fields: path::String : The literal string that was used to create the breakpoint, e.g.  \"path/file.jl\" . abspath ::String: The absolute path to the file when the breakpoint was created, e.g.  \"/Users/Someone/path/file.jl\" . For common fields shared by all breakpoints, see  AbstractBreakpoint . source"},{"id":229,"pagetitle":"Function reference","title":"Internal storage","ref":"/debug/stable/dev_reference/#Internal-storage","content":" Internal storage"},{"id":230,"pagetitle":"Function reference","title":"JuliaInterpreter.framedict","ref":"/debug/stable/dev_reference/#JuliaInterpreter.framedict","content":" JuliaInterpreter.framedict  —  Constant framedict[method]  returns the  FrameCode  for  method . For  @generated  methods, see  genframedict . source"},{"id":231,"pagetitle":"Function reference","title":"JuliaInterpreter.genframedict","ref":"/debug/stable/dev_reference/#JuliaInterpreter.genframedict","content":" JuliaInterpreter.genframedict  —  Constant genframedict[(method,argtypes)]  returns the  FrameCode  for a  @generated  method  method , for the particular argument types  argtypes . The framecodes stored in  genframedict  are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in  framedict . source"},{"id":232,"pagetitle":"Function reference","title":"JuliaInterpreter.compiled_methods","ref":"/debug/stable/dev_reference/#JuliaInterpreter.compiled_methods","content":" JuliaInterpreter.compiled_methods  —  Constant meth ∈ compiled_methods  indicates that  meth  should be run using  Compiled  rather than recursed into via the interpreter. source"},{"id":233,"pagetitle":"Function reference","title":"JuliaInterpreter.compiled_modules","ref":"/debug/stable/dev_reference/#JuliaInterpreter.compiled_modules","content":" JuliaInterpreter.compiled_modules  —  Constant mod ∈ compiled_modules  indicates that any method in  mod  should be run using  Compiled  rather than recursed into via the interpreter. source"},{"id":234,"pagetitle":"Function reference","title":"JuliaInterpreter.interpreted_methods","ref":"/debug/stable/dev_reference/#JuliaInterpreter.interpreted_methods","content":" JuliaInterpreter.interpreted_methods  —  Constant meth ∈ interpreted_methods  indicates that  meth  should  not  be run using  Compiled  and recursed into via the interpreter. This takes precedence over  compiled_methods  and  compiled_modules . source"},{"id":235,"pagetitle":"Function reference","title":"Utilities","ref":"/debug/stable/dev_reference/#Utilities","content":" Utilities"},{"id":236,"pagetitle":"Function reference","title":"JuliaInterpreter.eval_code","ref":"/debug/stable/dev_reference/#JuliaInterpreter.eval_code","content":" JuliaInterpreter.eval_code  —  Function eval_code(frame::Frame, code::Union{String, Expr}) Evaluate  code  in the context of  frame , updating any local variables (including type parameters) that are reassigned in  code , however, new local variables cannot be introduced. julia> foo(x, y) = x + y;\n\njulia> frame = JuliaInterpreter.enter_call(foo, 1, 3);\n\njulia> JuliaInterpreter.eval_code(frame, \"x + y\")\n4\n\njulia> JuliaInterpreter.eval_code(frame, \"x = 5\");\n\njulia> JuliaInterpreter.finish_and_return!(frame)\n8 When variables are captured in closures (and thus gets wrapped in a  Core.Box ) they will be automatically unwrapped and rewrapped upon evaluating them: julia> function capture()\n           x = 1\n           f = ()->(x = 2) # x captured in closure and is thus a Core.Box\n           f()\n           x\n       end;\n\njulia> frame = JuliaInterpreter.enter_call(capture);\n\njulia> JuliaInterpreter.step_expr!(frame);\n\njulia> JuliaInterpreter.step_expr!(frame);\n\njulia> JuliaInterpreter.locals(frame)\n2-element Vector{JuliaInterpreter.Variable}:\n #self# = capture\n x = Core.Box(1)\n\njulia> JuliaInterpreter.eval_code(frame, \"x\")\n1\n\njulia> JuliaInterpreter.eval_code(frame, \"x = 2\")\n2\n\njulia> JuliaInterpreter.locals(frame)\n2-element Vector{JuliaInterpreter.Variable}:\n #self# = capture\n x = Core.Box(2) \"Special\" values like SSA values and slots (shown in lowered code as e.g.  %3  and  @_4  respectively) can be evaluated using the syntax  var\"%3\"  and  var\"@_4\"  respectively. source"},{"id":237,"pagetitle":"Function reference","title":"JuliaInterpreter.@lookup","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@lookup","content":" JuliaInterpreter.@lookup  —  Macro rhs = @lookup(frame, node)\nrhs = @lookup(mod, frame, node) This macro looks up previously-computed values referenced as SSAValues, SlotNumbers, GlobalRefs, QuoteNode, sparam or exception reference expression. It will also lookup symbols in  moduleof(frame) ; this can be supplied ahead-of-time via the 3-argument version. If none of the above apply, the value of  node  will be returned. source"},{"id":238,"pagetitle":"Function reference","title":"JuliaInterpreter.is_wrapper_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_wrapper_call","content":" JuliaInterpreter.is_wrapper_call  —  Function Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or because of keyword arguments). source"},{"id":239,"pagetitle":"Function reference","title":"JuliaInterpreter.is_doc_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_doc_expr","content":" JuliaInterpreter.is_doc_expr  —  Function is_doc_expr(ex) Test whether expression  ex  is a  @doc  expression. source"},{"id":240,"pagetitle":"Function reference","title":"JuliaInterpreter.is_global_ref","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_global_ref","content":" JuliaInterpreter.is_global_ref  —  Function is_global_ref(g, mod, name) Tests whether  g  is equal to  GlobalRef(mod, name) . source"},{"id":241,"pagetitle":"Function reference","title":"CodeTracking.whereis","ref":"/debug/stable/dev_reference/#CodeTracking.whereis","content":" CodeTracking.whereis  —  Function loc = whereis(frame, pc::Int=frame.pc; macro_caller=false) Return the file and line number for  frame  at  pc .  If this cannot be determined,  loc == nothing . Otherwise  loc == (filepath, line) . By default, any statements expanded from a macro are attributed to the macro definition, but with macro_caller=true  you can obtain the location within the method that issued the macro. source"},{"id":242,"pagetitle":"Function reference","title":"JuliaInterpreter.linenumber","ref":"/debug/stable/dev_reference/#JuliaInterpreter.linenumber","content":" JuliaInterpreter.linenumber  —  Function line = linenumber(framecode, pc) Return the \"static\" line number at statement index  pc . The static line number is the location at the time the method was most recently defined. See  CodeTracking.whereis  for dynamic line information. source"},{"id":243,"pagetitle":"Function reference","title":"JuliaInterpreter.Variable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Variable","content":" JuliaInterpreter.Variable  —  Type Variable  is a struct representing a variable with an asigned value. By calling the function  locals  on a  Frame  a  Vector  of  Variable 's is returned. Important fields: value::Any : the value of the local variable. name::Symbol : the name of the variable as given in the source code. isparam::Bool : if the variable is a type parameter, for example  T  in  f(x::T) where {T} = x . is_captured_closure::Bool : if the variable has been captured by a closure source"},{"id":244,"pagetitle":"Function reference","title":"JuliaInterpreter.locals","ref":"/debug/stable/dev_reference/#JuliaInterpreter.locals","content":" JuliaInterpreter.locals  —  Function local_variables = locals(frame::Frame)::Vector{Variable} Return the local variables as a vector of  Variable . source"},{"id":245,"pagetitle":"Function reference","title":"JuliaInterpreter.whichtt","ref":"/debug/stable/dev_reference/#JuliaInterpreter.whichtt","content":" JuliaInterpreter.whichtt  —  Function method = whichtt(tt) Like  which  except it operates on the complete tuple-type  tt , and doesn't throw when there is no matching method. source"},{"id":246,"pagetitle":"Function reference","title":"Hooks","ref":"/debug/stable/dev_reference/#Hooks","content":" Hooks"},{"id":247,"pagetitle":"Function reference","title":"JuliaInterpreter.on_breakpoints_updated","ref":"/debug/stable/dev_reference/#JuliaInterpreter.on_breakpoints_updated","content":" JuliaInterpreter.on_breakpoints_updated  —  Function on_breakpoints_updated(f) Register a one-argument function to be called after any update to the set of all breakpoints. This includes their creation, deletion, enabling and disabling. The function  f  should take two inputs: First argument is the function doing to update, this is provided to allow to dispatch on its type. It will be one: ::typeof(breakpoint)  for the creation, ::typeof(remove)  for the deletion. ::typeof(update_states)  for disable/enable/toggleing Second argument is the breakpoint object that was changed. If only desiring to handle some kinds of update,  f  should have fallback methods to do nothing in the general case. Warning This feature is experimental, and may be modified or removed in a minor release. source"},{"id":248,"pagetitle":"Function reference","title":"JuliaInterpreter.firehooks","ref":"/debug/stable/dev_reference/#JuliaInterpreter.firehooks","content":" JuliaInterpreter.firehooks  —  Function firehooks(hooked_fun, bp::AbstractBreakpoint) Trigger all hooks that were registered with  on_breakpoints_updated , passing them the  hooked_fun  and the  bp . This should be called whenever the set of breakpoints is updated.  hooked_fun  is the function doing the update, and  bp  is the relevent breakpoint being updated  after  the update is applied. Warning This feature is experimental, and may be modified or removed in a minor release. source"},{"id":251,"pagetitle":"Internals","title":"Internals","ref":"/debug/stable/internals/#Internals","content":" Internals"},{"id":252,"pagetitle":"Internals","title":"Basic usage","ref":"/debug/stable/internals/#Basic-usage","content":" Basic usage The process of executing code in the interpreter is to prepare a  frame  and then evaluate these statements one-by-one, branching via the  goto  statements as appropriate. Using the  summer  example described in  Lowered representation , let's build a frame: julia> frame = JuliaInterpreter.enter_call(summer, A)\nFrame for summer(A::AbstractArray{T,N} where N) where T in Main at REPL[2]:2\n   1* 2  1 ─       s = (zero)($(Expr(:static_parameter, 1)))\n   2  3  │   %2  = A\n   3  3  │         #temp# = (iterate)(%2)\n⋮\nA = [1, 2, 5]\nT = Int64 This is a  Frame . Only a portion of the  CodeInfo  is shown, a small region surrounding the current statement (marked with  *  or in yellow text). The full  CodeInfo  can be extracted as  code = frame.framecode.src . (It's a slightly modified form of one returned by  @code_lowered , in that it has been processed by  JuliaInterpreter.optimize!  to speed up run-time execution.) frame  has another field,  framedata , that holds values needed for or generated by execution. The input arguments and local variables are in  locals : julia> frame.framedata.locals\n5-element Array{Union{Nothing, Some{Any}},1}:\n Some(summer)\n Some([1, 2, 5])\n nothing\n nothing\n nothing These correspond to the  code.slotnames ; the first is the  #self#  argument and the second is the input array. The remaining local variables (e.g.,  s  and  a ), have not yet been assigned–-we've only built the frame, but we haven't yet begun to execute it. The static parameter,  T , is stored in  frame.framedata.sparams : julia> frame.framedata.sparams\n1-element Array{Any,1}:\n Int64 The  Expr(:static_parameter, 1)  statement refers to this value. The other main storage is for the generated SSA values: julia> frame.framedata.ssavalues\n16-element Array{Any,1}:\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef Since we haven't executed any statements yet, these are all undefined. The other main entity is the so-called  program counter , which just indicates the next statement to be executed: julia> frame.pc\n1 Let's try executing the first statement: julia> JuliaInterpreter.step_expr!(frame)\n2 This indicates that it ran statement 1 and is prepared to run statement 2. (It's worth noting that the first line included a  call  to  zero , so behind the scenes JuliaInterpreter created a new frame for  zero , executed all the statements, and then popped back to  frame .) Since the first statement is an assignment of a local variable, let's check the locals again: julia> frame.framedata.locals\n5-element Array{Union{Nothing, Some{Any}},1}:\n Some(summer)\n Some([1, 2, 5])\n Some(0)\n nothing\n nothing You can see that the entry corresponding to  s  has been initialized. The next statement just retrieves one of the slots (the input argument  A ) and stores it in an SSA value: julia> JuliaInterpreter.step_expr!(frame)\n3\n\njulia> frame.framedata.ssavalues\n16-element Array{Any,1}:\n #undef\n    [1, 2, 5]\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef One can easily continue this until execution completes, which is indicated when  step_expr!  returns  nothing . Alternatively, use the higher-level  JuliaInterpreter.finish!(frame)  to step through the entire frame, or  JuliaInterpreter.finish_and_return!(frame)  to also obtain the return value."},{"id":253,"pagetitle":"Internals","title":"More complex expressions","ref":"/debug/stable/internals/#More-complex-expressions","content":" More complex expressions Sometimes you might have a whole sequence of expressions you want to run. In such cases, your first thought should be to construct the  Frame  manually. Here's a demonstration: using Test\n\nex = quote\n    x, y = 1, 2\n    @test x + y == 3\nend\n\nframe = Frame(Main, ex)\nJuliaInterpreter.finish_and_return!(frame)\n\n# output\n\nTest Passed\n  Expression: x + y == 3\n   Evaluated: 3 == 3"},{"id":254,"pagetitle":"Internals","title":"Toplevel code and world age","ref":"/debug/stable/internals/#Toplevel-code-and-world-age","content":" Toplevel code and world age Code that defines new  struct s, new methods, or new modules is a bit more complicated and requires special handling. In such cases, calling  finish_and_return!  on a frame that defines these new objects and then calls them can trigger a  world age error , in which the method is considered to be too new to be run by the currently compiled code. While one can resolve this by using  Base.invokelatest , we'd have to use that strategy throughout the entire package.  This would cause a major reduction in performance. To resolve this issue without leading to performance problems, care is required to return to \"top level\" after defining such objects. This leads to altered syntax for executing such expressions. Here's a demonstration of the problem: ex = :(map(x->x^2, [1, 2, 3]))\nframe = Frame(Main, ex)\njulia> JuliaInterpreter.finish_and_return!(frame)\nERROR: this frame needs to be run a top level The reason for this error becomes clearer if we examine  frame  or look directly at the lowered code: julia> Meta.lower(Main, ex)\n:($(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─      global var\"#3#4\"\n│        const var\"#3#4\"\n│   %3 = Core._structtype(Main, Symbol(\"#3#4\"), Core.svec(), Core.svec(), Core.svec(), false, 0)\n│        var\"#3#4\" = %3\n│        Core._setsuper!(var\"#3#4\", Core.Function)\n│        Core._typebody!(var\"#3#4\", Core.svec())\n└──      return nothing\n)))\n│   %2 = Core.svec(var\"#3#4\", Core.Any)\n│   %3 = Core.svec()\n│   %4 = Core.svec(%2, %3, $(QuoteNode(:(#= REPL[18]:1 =#))))\n│        $(Expr(:method, false, :(%4), CodeInfo(\n    @ REPL[18]:1 within `none`\n1 ─ %1 = Core.apply_type(Base.Val, 2)\n│   %2 = (%1)()\n│   %3 = Base.literal_pow(^, x, %2)\n└──      return %3\n)))\n│        #3 = %new(var\"#3#4\")\n│   %7 = #3\n│   %8 = Base.vect(1, 2, 3)\n│   %9 = map(%7, %8)\n└──      return %9\n)))) All of the code before the  %7  line is devoted to defining the anonymous function  x->x^2 : it creates a new \"anonymous type\" (here written as  var\"#3#4\" ), and then defines a \"call function\" for this type, equivalent to  (var\"#3#4\")(x) = x^2 . In some cases one can fix this simply by indicating that we want to run this frame at top level: julia> JuliaInterpreter.finish_and_return!(frame, true)\n3-element Array{Int64,1}:\n 1\n 4\n 9 In other cases, such as nested calls of new methods, you may need to allow the world age to update between evaluations. In such cases you want to use  ExprSplitter : for (mod, e) in ExprSplitter(Main, ex)\n    frame = Frame(mod, e)\n    while true\n        JuliaInterpreter.through_methoddef_or_done!(frame) === nothing && break\n    end\n    JuliaInterpreter.get_return(frame)\nend This splits the expression into a sequence of frames (here just one, but more complex blocks may be split up into many). Then, each frame is executed until it finishes defining a new method, then returns to top level. The return to top level causes an update in the world age. If the frame hasn't been finished yet (if the return value wasn't  nothing ), this continues executing where it left off. (Incidentally,  JuliaInterpreter.enter_call(map, x->x^2, [1, 2, 3])  works fine on its own, because the anonymous function is defined by the caller–-you'll see that the created frame is very simple.)"},{"id":259,"pagetitle":"Infiltrator.jl","title":"Infiltrator.jl","ref":"/inf/stable/#Infiltrator.jl","content":" Infiltrator.jl This packages provides the  @infiltrate  macro, which acts as a breakpoint with neglible runtime performance overhead. Note that you cannot access other function scopes or step into further calls. Use an actual debugger if you need that level of flexibility. Running code that ends up triggering the  @infiltrate  REPL mode via inline evaluation in VS Code or Juno can cause issues, so it's recommended to always use the REPL directly."},{"id":260,"pagetitle":"Infiltrator.jl","title":"@infiltrate","ref":"/inf/stable/#@infiltrate","content":" @infiltrate @infiltrate cond = true @infiltrate  sets an infiltration point. When the infiltration point is hit, it will drop you into an interactive REPL session that lets you inspect local variables and the call stack as well as execute aribtrary statements in the context of the current local and global scope. The optional argument  cond  only enables this infiltration point if it evaluates to  true . You can also use if isdefined(Main, :Infiltrator)\n  Main.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\nend to infiltrate package code without any post-hoc evaluation into the module (because the functional form does not require Infiltrator to be loaded at compiletime)."},{"id":261,"pagetitle":"Infiltrator.jl","title":"@exfiltrate","ref":"/inf/stable/#@exfiltrate","content":" @exfiltrate @exfiltrate Assigns all local variables into global storage."},{"id":262,"pagetitle":"Infiltrator.jl","title":"The safehouse","ref":"/inf/stable/#The-safehouse","content":" The safehouse Exfiltrating variables (with  @exfiltrate  or by assignment in an  @infiltrate  session) happens by assigning the variable to a global storage space (backed by a module); any exfiltrated objects can be directly accessed, via  Infiltrator.store  or its exported aliases  safehouse  or  exfiltrated : julia> foo(x) = @exfiltrate\nfoo (generic function with 1 method)\n\njulia> foo(3)\n\njulia> safehouse.x # or exfiltrated.x\n3 You can reset the safehouse with  Infiltrator.clear_store!() . You can also assign a specific module with  Infiltrator.set_store!(mod) . This allows you to e.g. set the backing module to  Main  and therefore export the contents of the safehouse to the global namespace (although doing so is not recommended)."},{"id":263,"pagetitle":"Infiltrator.jl","title":"Example usage","ref":"/inf/stable/#Example-usage","content":" Example usage julia> function f(x)\n         out = []\n         for i in x\n           push!(out, 2i)\n           @infiltrate\n         end\n         out\n       end\nf (generic function with 1 method)\n\njulia> f([1,2,3])\nInfiltrating f(x::Vector{Int64})\n  at REPL[10]:5\n\ninfil> ?\n  Code entered here is evaluated in the current scope. Changes to local variables are not possible; global variables can only be changed with eval/@eval.\n\n  All assignments will end up in the safehouse.\n\n  The following commands are special cased:\n\n    •  ?: Print this help text.\n\n    •  @trace: Print the current stack trace.\n\n    •  @locals: Print local variables. @locals x y only prints x and y.\n\n    •  @exfiltrate: Save all local variables into the store. @exfiltrate x y saves x and y; this variant can also exfiltrate variables defined in the infil> REPL.\n\n    •  @toggle: Toggle infiltrating at this @infiltrate spot (clear all with Infiltrator.clear_disabled!()).\n\n    •  @continue: Continue to the next infiltration point or exit (shortcut: Ctrl-D).\n\n    •  @doc symbol: Get help for symbol (same as in the normal Julia REPL).\n\n    •  @exit: Stop infiltrating for the remainder of this session and exit (on Julia versions prior to 1.5 this needs to be manually cleared with Infiltrator.end_session!()).\n\ninfil> @locals\n- out::Vector{Any} = Any[2]\n- i::Int64 = 1\n- x::Vector{Int64} = [1, 2, 3]\n\ninfil> 0//0\nERROR: ArgumentError: invalid rational: zero(Int64)//zero(Int64)\nStacktrace:\n [1] __throw_rational_argerror_zero(T::Type)\n   @ Base ./rational.jl:32\n [2] Rational{Int64}(num::Int64, den::Int64)\n   @ Base ./rational.jl:34\n [3] Rational\n   @ ./rational.jl:39 [inlined]\n [4] //(n::Int64, d::Int64)\n   @ Base ./rational.jl:62\n [5] top-level scope\n   @ none:1\n\ninfil> @toggle\nDisabled infiltration at this infiltration point.\n\ninfil> @toggle\nEnabled infiltration at this infiltration point.\n\ninfil> @continue\n\nInfiltrating f(x::Vector{Int64})\n  at REPL[10]:5\n\ninfil> intermediate = copy(out)\n2-element Vector{Any}:\n 2\n 4\n\ninfil> @exfiltrate intermediate x\nExfiltrating 2 local variables into the safehouse.\n\ninfil> @exit\n\n3-element Vector{Any}:\n 2\n 4\n 6\n\njulia> safehouse.intermediate\n2-element Vector{Any}:\n 2\n 4\n\njulia> @withstore begin\n         x = 23\n         x .* intermediate\n       end\n2-element Vector{Int64}:\n 46\n 92"},{"id":264,"pagetitle":"Infiltrator.jl","title":"Related projects","ref":"/inf/stable/#Related-projects","content":" Related projects @exfiltrate  for Python"},{"id":267,"pagetitle":"API","title":"API","ref":"/inf/stable/API/#API","content":" API"},{"id":268,"pagetitle":"API","title":"Infiltration and exfiltration","ref":"/inf/stable/API/#Infiltration-and-exfiltration","content":" Infiltration and exfiltration Add  @infiltrate  to any function to start the  infil>  REPL mode when that line runs. It's recommended to put Infiltrator.jl into your global environment and not into package environments for two reasons: Infiltrator.jl is intended as a development tool only and as such should not be shipped Any  @infiltrate  invocations in your package code will fail at compile-time, which prevents you from accidentally committing infiltrated code This means that you'll need to use  Revise.jl , inline evaluation in VS Code, or just plain old  @eval  to apply  @infiltrate  statements in your package code."},{"id":269,"pagetitle":"API","title":"Infiltrator.@infiltrate","ref":"/inf/stable/API/#Infiltrator.@infiltrate","content":" Infiltrator.@infiltrate  —  Macro @infiltrate cond = true @infiltrate  sets an infiltration point (or breakpoint). When the infiltration point is hit, it will drop you into an interactive REPL session that lets you inspect local variables and the call stack as well as execute aribtrary statements in the context of the current functions module. This macro also accepts an optional argument  cond  that must evaluate to a boolean, and then this macro will serve as a \"conditinal breakpoint\", which starts inspections only when its condition is  true . source"},{"id":270,"pagetitle":"API","title":"Infiltrator.infiltrate","ref":"/inf/stable/API/#Infiltrator.infiltrate","content":" Infiltrator.infiltrate  —  Function infiltrate(mod, locals, file, line) Function form of  @infiltrate . Use this to conditionally infiltrate package code without using e.g. Revise (because this version is valid during precompilation). This would typically be used as if isdefined(Main, :Infiltrator)\n  Main.infiltrate(@__MODULE__, Base.@locals, @__FILE__, @__LINE__)\nend source"},{"id":271,"pagetitle":"API","title":"Infiltrator.@exfiltrate","ref":"/inf/stable/API/#Infiltrator.@exfiltrate","content":" Infiltrator.@exfiltrate  —  Macro @exfiltrate Assigns all local variables into the global storage. source"},{"id":272,"pagetitle":"API","title":"The safehouse","ref":"/inf/stable/API/#The-safehouse","content":" The safehouse This is where all exfiltrated variables end up. You can either exfiltrate a variable explicitly with  @exfiltrate  or implicitly by assignment in the  infil>  REPL mode."},{"id":273,"pagetitle":"API","title":"Infiltrator.safehouse","ref":"/inf/stable/API/#Infiltrator.safehouse","content":" Infiltrator.safehouse  —  Constant safehouse\nexfiltrated\nInfiltrator.store Global storage for storing values while  @infiltrate ing or  @exfiltrate ing. Also see  clear_store! ,  set_store! , and  @withstore  for safehouse-related functionality. source"},{"id":274,"pagetitle":"API","title":"Infiltrator.clear_store!","ref":"/inf/stable/API/#Infiltrator.clear_store!","content":" Infiltrator.clear_store!  —  Function clear_store!(s = safehouse) Reset the store used for global symbols. source"},{"id":275,"pagetitle":"API","title":"Infiltrator.set_store!","ref":"/inf/stable/API/#Infiltrator.set_store!","content":" Infiltrator.set_store!  —  Function set_store!(s = safehouse, m::Module) Set the module backing the store  s . source"},{"id":276,"pagetitle":"API","title":"Infiltrator.@withstore","ref":"/inf/stable/API/#Infiltrator.@withstore","content":" Infiltrator.@withstore  —  Macro @withstore ex Evaluates the expression  ex  in the context of the global store. Mainly intended for interactive use, as changes to the store's state will not propagate into the returned expression. source"},{"id":277,"pagetitle":"API","title":"Utility","ref":"/inf/stable/API/#Utility","content":" Utility"},{"id":278,"pagetitle":"API","title":"Infiltrator.clear_disabled!","ref":"/inf/stable/API/#Infiltrator.clear_disabled!","content":" Infiltrator.clear_disabled!  —  Function clear_disabled!(s = safehouse) Clear all disabled infiltration points. source"},{"id":279,"pagetitle":"API","title":"Infiltrator.end_session!","ref":"/inf/stable/API/#Infiltrator.end_session!","content":" Infiltrator.end_session!  —  Function end_session!(s = safehouse) End this infiltration session (reverts the effect of  @exit  in the  debug>  REPL). Only needs to be manually called on Julia versions prior to 1.5. source"},{"id":280,"pagetitle":"API","title":"Infiltrator.toggle_async_check","ref":"/inf/stable/API/#Infiltrator.toggle_async_check","content":" Infiltrator.toggle_async_check  —  Function toggle_async_check(enabled) Enable or disable the check for safe REPL mode switching. May result in a non-functional REPL. source"},{"id":285,"pagetitle":"Home","title":"JuliaInterpreter","ref":"/debug/stable/#JuliaInterpreter","content":" JuliaInterpreter This package implements an  interpreter  for Julia code. Normally, Julia compiles your code when you first execute it; using JuliaInterpreter you can avoid compilation and execute the expressions that define your code directly. Interpreters have a number of applications, including support for stepping debuggers."},{"id":286,"pagetitle":"Home","title":"Use as an interpreter","ref":"/debug/stable/#Use-as-an-interpreter","content":" Use as an interpreter Using this package as an interpreter is straightforward: julia> using JuliaInterpreter\n\njulia> list = [1, 2, 5]\n3-element Vector{Int64}:\n 1\n 2\n 5\n\njulia> sum(list)\n8\n\njulia> @interpret sum(list)\n8"},{"id":287,"pagetitle":"Home","title":"Breakpoints","ref":"/debug/stable/#Breakpoints","content":" Breakpoints You can interrupt execution by setting breakpoints. You can set breakpoints via packages that explicitly target debugging, like  Juno ,  Debugger , and  Rebugger . But all of these just leverage the core functionality defined in JuliaInterpreter, so here we'll illustrate it without using any of these other packages. Let's set a conditional breakpoint, to be triggered any time one of the elements in the argument to  sum  is bigger than 4: julia> bp = @breakpoint sum([1, 2]) any(x->x>4, a); Note that in writing the condition, we used  a , the name of the argument to the relevant method of  sum . Conditionals should be written using a combination of argument and parameter names of the method into which you're inserting a breakpoint; you can also use any globally-available name (as used here with the  any  function). Now let's see what happens: julia> @interpret sum([1,2,3])  # no element bigger than 4, breakpoint should not trigger\n6\n\njulia> frame, bpref = @interpret sum([1,2,5])  # should trigger breakpoint\n(Frame for sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873\nc 1* 873  1 ─      nothing\n  2  873  │   %2 = ($(QuoteNode(NamedTuple)))()\n  3  873  │   %3 = Base.pairs(%2)\n⋮\na = [1, 2, 5], breakpoint(sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873, line 873)) frame  is described in more detail on the next page; for now, suffice it to say that the  c  in the leftmost column indicates the presence of a conditional breakpoint upon entry to  sum .  bpref  is a reference to the breakpoint of type  BreakpointRef . The breakpoint  bp  we created can be manipulated at the command line julia> disable(bp)\n\njulia> @interpret sum([1,2,5])\n8\n\njulia> enable(bp)\n\njulia> @interpret sum([1,2,5])\n(Frame for sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873\nc 1* 873  1 ─      nothing\n  2  873  │   %2 = ($(QuoteNode(NamedTuple)))()\n  3  873  │   %3 = Base.pairs(%2)\n⋮\na = [1, 2, 5], breakpoint(sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:873, line 873)) disable  and  enable  allow you to turn breakpoints off and on without losing any conditional statements you may have provided;  remove  allows a permanent removal of the breakpoint. You can use  remove()  to remove all breakpoints in all methods. @breakpoint  allows you to optionally specify a line number at which the breakpoint is to be set. You can also use a functional form,  breakpoint , to specify file/line combinations or that you want to break on entry to  any  method of a particular function. At present, note that some of this functionality requires that you be running  Revise.jl . It is, in addition, possible to halt execution when otherwise an error would be thrown. This functionality is enabled using  break_on  and disabled with  break_off : julia> function f_outer()\n           println(\"before error\")\n           f_inner()\n           println(\"after error\")\n       end;\n\njulia> f_inner() = error(\"inner error\");\n\njulia> break_on(:error)\n\njulia> fr, pc = @interpret f_outer()\nbefore error\n(Frame for f_outer() in Main at none:1\n  1  2  1 ─      Base.println(\"before error\")\n  2* 3  │        f_inner()\n  3  4  │   %3 = Base.println(\"after error\")\n  4  4  └──      return %3\ncallee: f_inner() in Main at none:1, breakpoint(error(s::AbstractString) in Base at error.jl:33, line 33, ErrorException(\"inner error\")))\n\njulia> leaf(fr)\nFrame for error(s::AbstractString) in Base at error.jl:33\n  1  33  1 ─ %1 = ($(QuoteNode(ErrorException)))(s)\n  2* 33  │   %2 = Core.throw(%1)\n  3  33  └──      return %2\ns = \"inner error\"\ncaller: f_inner() in Main at none:1\n\njulia> typeof(pc)\nBreakpointRef\n\njulia> pc.err\nErrorException(\"inner error\")\n\njulia> break_off(:error)\n\njulia> @interpret f_outer()\nbefore error\nERROR: inner error\nStacktrace:\n[...] Finally, you can set breakpoints using  @bp : julia> function myfunction(x, y)\n           a = 1\n           b = 2\n           x > 3 && @bp\n           return a + b + x + y\n       end\nmyfunction (generic function with 1 method)\n\njulia> @interpret myfunction(1, 2)\n6\n\njulia> @interpret myfunction(5, 6)\n(Frame for myfunction(x, y) in Main at none:1\n⋮\n  3  4  │   %3 = x > 3\n  4  4  └──      goto #3 if not %3\nb 5* 4  2 ─      nothing\n  6  4  └──      goto #3\n  7  5  3 ┄ %7 = a + b + x + y\n⋮\nx = 5\ny = 6\nb = 2\na = 1, breakpoint(myfunction(x, y) in Main at none:1, line 4)) Here the breakpoint is marked with a  b  indicating that it is an unconditional breakpoint. Because we placed it inside the condition  x > 3 , we've achieved a conditional outcome. When using  @bp  in source-code files, the use of Revise is recommended, since it allows you to add breakpoints, test code, and then remove the breakpoints from the code without restarting Julia."},{"id":288,"pagetitle":"Home","title":"debug_command","ref":"/debug/stable/#debug_command","content":" debug_command You can control execution of frames via  debug_command . Authors of debugging applications should target  debug_command  for their interaction with JuliaInterpreter."},{"id":289,"pagetitle":"Home","title":"Hooks","ref":"/debug/stable/#Hooks","content":" Hooks Consider if you were building a debugging application with a GUI component which displays a dot in the text editor margin where a breakpoint is. If a user creates a breakpoint not via your GUI, but rather via a command in the REPL etc. then you still wish to keep your GUI up to date. How to do this? The answer is hooks. JuliaInterpreter has experimental support for having  a hook, or callback function invoked whenever the set of all breakpoints is changed. Hook functions are setup by invoking the  JuliaInterpreter.on_breakpoints_updated  function. To return to our example of keeping GUI up to date, the hooks would look something like this: using JuliaInterpreter\nusing JuliaInterpreter: AbstractBreakpoint, update_states!, on_breakpoints_updated\n\nbreakpoint_gui_elements = Dict{AbstractBreakpoint, MarginDot}()\n# ...\nfunction breakpoint_gui_hook(::typeof(breakpoint), bp::AbstractBreakpoint)\n    bp_dot = MarginDot(bp)\n    draw(bp_dot)\n    breakpoint_gui_elements[bp] = bp_dot\nend\n\nfunction breakpoint_gui_hook(::typeof(remove), bp::AbstractBreakpoint)\n    bp_dot = pop!(breakpoint_gui_elements, bp)\n    undraw(bp_dot)\nend\n\nfunction breakpoint_gui_hook(::typeof(update_states!), bp::AbstractBreakpoint)\n    is_enabled = bp.enabled[]\n    bp_dot = breakpoint_gui_elements[bp]\n    set_fill!(bp_dot, is_enabled ? :blue : :grey)\nend\n\non_breakpoints_updated(breakpoint_gui_hook)"},{"id":292,"pagetitle":"Lowered representation","title":"Lowered representation","ref":"/debug/stable/ast/#Lowered-representation","content":" Lowered representation JuliaInterpreter uses the lowered representation of code. The key advantage of lowered representation is that it is fairly well circumscribed: There are only a limited number of legal statements that can appear in lowered code Each statement is \"unpacked\" to essentially do one thing Scoping of variables is simplified via the slot mechanism, described below Names are fully resolved by module Macros are expanded Julia AST  describes the kinds of objects that can appear in lowered code. Let's start with a demonstration on a simple function: function summer(A::AbstractArray{T}) where T\n    s = zero(T)\n    for a in A\n        s += a\n    end\n    return s\nend\n\nA = [1, 2, 5] To interpret lowered representation, it maybe be useful to rewrite the body of  summer  in the following ways. First let's use an intermediate representation that expands the  for a in A ... end  loop:     s = zero(T)\n    temp = iterate(A)         # `for` loops get lowered to `iterate/while` loops\n    while temp !== nothing\n        a, state = temp\n        s += a\n        temp = iterate(A, state)\n    end\n    return s The lowered code takes the additional step of resolving the names by module and turning all the branching into  @goto/@label  equivalents:     # Code starting at line 2 (the first line of the body)\n    s = Main.zero(T)       # T corresponds to the first parameter, i.e., $(Expr(:static_parameter, 1))\n\n    # Code starting at line 3\n    temp = Base.iterate(A) # here temp = @_4\n    if temp === nothing    # this comparison gets stored as %4, and %5 stores !(temp===nothing)\n        @goto block4\n    end\n\n    @label block2\n        ## BEGIN block2\n        a, state = temp[1], temp[2]  # these correspond to the `getfield` calls, state is %9\n\n        # Code starting at line 4\n        s = s + a\n\n        # Code starting at line 5\n        temp = iterate(A, state)     # A is also %2\n        if temp === nothing\n            @goto block4             # the `while` condition was false\n        end\n        ## END block2\n\n    @goto block2           # here the `while` condition is still true\n\n    # Code starting at line 6\n    @label block4\n        ## BEGIN block4\n        return s\n        ## END block4 This has very close correspondence to the lowered representation: julia> code = @code_lowered debuginfo=:source summer(A)\nCodeInfo(\n    @ REPL[1]:2 within `summer'\n1 ─       s = Main.zero($(Expr(:static_parameter, 1)))\n│   @ REPL[1]:3 within `summer'\n│   %2  = A\n│         @_4 = Base.iterate(%2)\n│   %4  = @_4 === nothing\n│   %5  = Base.not_int(%4)\n└──       goto #4 if not %5\n2 ┄ %7  = @_4\n│         a = Core.getfield(%7, 1)\n│   %9  = Core.getfield(%7, 2)\n│   @ REPL[1]:4 within `summer'\n│         s = s + a\n│         @_4 = Base.iterate(%2, %9)\n│   %12 = @_4 === nothing\n│   %13 = Base.not_int(%12)\n└──       goto #4 if not %13\n3 ─       goto #2\n    @ REPL[1]:6 within `summer'\n4 ┄       return s\n) Note Not all Julia versions support  debuginfo . If the command above fails for you, just omit the  debuginfo=:source  portion. To understand this package's internals, you need to familiarize yourself with these  CodeInfo  objects. The lines that start with  @ REPL[1]:n  indicate the source line of the succeeding block of statements; here we defined this method in the REPL, so the source file is  REPL[1] ; the number after the colon is the line number. The numbers on the left correspond to  basic blocks , as we annotated with  @label block2  above. When used in statements these are printed with a hash, e.g., in  goto #4 if not %5 , the  #4  refers to basic block 4. The numbers in the next column–e.g.,  %2 , refer to  single static assignment (SSA) values . Each statement (each line of this printout) corresponds to a single SSA value, but only those used later in the code are printed using assignment syntax. Wherever a previous SSA value is used, it's referenced by an  SSAValue  and printed as  %5 ; for example, in  goto #4 if not %5 , the  %5  is the result of evaluating the 5th statement, which is  (Base.not_int)(%4) , which in turn refers to the result of statement 4. Finally, temporary variables here are shown as  @_4 ; the  _  indicates a  slot , either one of the input arguments or a local variable, and the 4 means the 4th one. Together lines 4 and 5 correspond to  !(@_4 === nothing) , where  @_4  has been assigned the result of the call to  iterate  occurring on line 3. (In some Julia versions, this may be printed as  #temp# , similar to how we named it in our alternative implementation above.) Let's look at a couple of the fields of the  CodeInfo . First, the statements themselves: julia> code.code\n16-element Array{Any,1}:\n :(_3 = Main.zero($(Expr(:static_parameter, 1))))\n :(_2)\n :(_4 = Base.iterate(%2))\n :(_4 === nothing)\n :(Base.not_int(%4))\n :(unless %5 goto %16)\n :(_4)\n :(_5 = Core.getfield(%7, 1))\n :(Core.getfield(%7, 2))\n :(_3 = _3 + _5)\n :(_4 = Base.iterate(%2, %9))\n :(_4 === nothing)\n :(Base.not_int(%12))\n :(unless %13 goto %16)\n :(goto %7)\n :(return _3) You can see directly that the SSA assignments are implicit; they are not directly present in the statement list. The most noteworthy change here is the appearance of more objects like  _3 , which are references that index into local variable slots: julia> code.slotnames\n5-element Array{Any,1}:\n Symbol(\"#self#\")\n :A\n :s\n Symbol(\"\")\n :a When printing the whole  CodeInfo  object, these  slotnames  are substituted in (unless they are empty, as was the case for  @_4  above)."},{"id":295,"pagetitle":"Function reference","title":"Function reference","ref":"/debug/stable/dev_reference/#Function-reference","content":" Function reference"},{"id":296,"pagetitle":"Function reference","title":"Running the interpreter","ref":"/debug/stable/dev_reference/#Running-the-interpreter","content":" Running the interpreter"},{"id":297,"pagetitle":"Function reference","title":"JuliaInterpreter.@interpret","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@interpret","content":" JuliaInterpreter.@interpret  —  Macro @interpret f(args; kwargs...) Evaluate  f  on the specified arguments using the interpreter. Example julia> a = [1, 7]\n2-element Vector{Int64}:\n 1\n 7\n\njulia> sum(a)\n8\n\njulia> @interpret sum(a)\n8 source"},{"id":298,"pagetitle":"Function reference","title":"Frame creation","ref":"/debug/stable/dev_reference/#Frame-creation","content":" Frame creation"},{"id":299,"pagetitle":"Function reference","title":"JuliaInterpreter.Frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Frame-Tuple{Module, Expr}","content":" JuliaInterpreter.Frame  —  Method frame = Frame(mod::Module, ex::Expr) Construct a  Frame  to evaluate  ex  in module  mod . This constructor can error, for example if lowering  ex  results in an  :error  or  :incomplete  expression, or if it otherwise fails to return a  :thunk . source"},{"id":300,"pagetitle":"Function reference","title":"JuliaInterpreter.ExprSplitter","ref":"/debug/stable/dev_reference/#JuliaInterpreter.ExprSplitter","content":" JuliaInterpreter.ExprSplitter  —  Type ExprSplitter(mod::Module, ex::Expr; lnn=nothing) Create an iterable that returns individual expressions together with their module of evaluation. Optionally supply an initial  LineNumberNode lnn . Example julia> expr = quote\n           public(x::Integer) = true\n           module Private\n           private(y::String) = false\n           end\n           const threshold = 0.1\n       end;\n\njulia> for (mod, ex) in ExprSplitter(Main, expr)\n           @show mod ex\n       end\nmod = Main\nex = quote\n    #= REPL[7]:2 =#\n    public(x::Integer) = begin\n            #= REPL[7]:2 =#\n            true\n        end\nend\nmod = Main.Private\nex = quote\n    #= REPL[7]:4 =#\n    private(y::String) = begin\n            #= REPL[7]:4 =#\n            false\n        end\nend\nmod = Main\nex = :($(Expr(:toplevel, :(()), :(const threshold = 0.1)))) Note that  Main.Private  was created for you so that its internal expressions could be evaluated.  ExprSplitter  will check to see whether the module already exists and if so return it rather than try to create a new module with the same name. In general each returned expression is a block with two parts: a  LineNumberNode  followed by a single expression. In some cases the returned expression may be  :toplevel , as shown in the  const  declaration, but otherwise it will be a  :block . World age, frame creation, and evaluation The primary purpose of  ExprSplitter  is to allow sequential return to top-level (e.g., the REPL) after evaluation of each expression. Returning to top-level allows the world age to update, and hence allows one to call methods and use types defined in earlier expressions in a block. For evaluation by JuliaInterpreter, the returned module/expression pairs can be passed directly to the  Frame  constructor. However, some expressions cannot be converted into  Frame s and may need special handling: julia> for (mod, ex) in ExprSplitter(Main, expr)\n           if ex.head === :global\n               # global declarations can't be lowered to a CodeInfo.\n               # In this demo we choose to evaluate them, but you can do something else.\n               Core.eval(mod, ex)\n               continue\n           end\n           frame = Frame(mod, ex)\n           debug_command(frame, :c, true)\n       end\n\njulia> threshold\n0.1\n\njulia> public(3)\ntrue If you're parsing package code,  ex  might be a docstring-expression; you may wish to check for such expressions and take distinct actions. See  Frame(mod::Module, ex::Expr)  for more information about frame creation. source"},{"id":301,"pagetitle":"Function reference","title":"JuliaInterpreter.enter_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enter_call","content":" JuliaInterpreter.enter_call  —  Function frame = enter_call(f, args...; kwargs...) Build a  Frame  ready to execute  f  with the specified positional and keyword arguments. Example julia> mymethod(x) = x+1\nmymethod (generic function with 1 method)\n\njulia> JuliaInterpreter.enter_call(mymethod, 1)\nFrame for mymethod(x) in Main at none:1\n  1* 1  1 ─ %1 = x + 1\n  2  1  └──      return %1\nx = 1\n\njulia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 2 methods)\n\njulia> JuliaInterpreter.enter_call(mymethod, [1.0, 2.0])\nFrame for mymethod(x::Vector{T}) where T in Main at none:1\n  1* 1  1 ─     return 1\nx = [1.0, 2.0]\nT = Float64 For a  @generated  function you can use  enter_call((f, true), args...; kwargs...)  to execute the generator of a  @generated  function, rather than the code that would be created by the generator. See  enter_call_expr  for a similar approach based on expressions. source"},{"id":302,"pagetitle":"Function reference","title":"JuliaInterpreter.enter_call_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enter_call_expr","content":" JuliaInterpreter.enter_call_expr  —  Function frame = enter_call_expr(expr; enter_generated=false) Build a  Frame  ready to execute the expression  expr . Set  enter_generated=true  if you want to execute the generator of a  @generated  function, rather than the code that would be created by the generator. Example julia> mymethod(x) = x+1\nmymethod (generic function with 1 method)\n\njulia> JuliaInterpreter.enter_call_expr(:($mymethod(1)))\nFrame for mymethod(x) in Main at none:1\n  1* 1  1 ─ %1 = x + 1\n  2  1  └──      return %1\nx = 1\n\njulia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 2 methods)\n\njulia> a = [1.0, 2.0]\n2-element Vector{Float64}:\n 1.0\n 2.0\n\njulia> JuliaInterpreter.enter_call_expr(:($mymethod($a)))\nFrame for mymethod(x::Vector{T}) where T in Main at none:1\n  1* 1  1 ─     return 1\nx = [1.0, 2.0]\nT = Float64 See  enter_call  for a similar approach not based on expressions. source"},{"id":303,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_frame","content":" JuliaInterpreter.prepare_frame  —  Function frame = prepare_frame(framecode::FrameCode, frameargs, lenv) Construct a new  Frame  for  framecode , given lowered-code arguments  frameargs  and static parameters  lenv . See  JuliaInterpreter.prepare_call  for information about how to prepare the inputs. source"},{"id":304,"pagetitle":"Function reference","title":"JuliaInterpreter.determine_method_for_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.determine_method_for_expr","content":" JuliaInterpreter.determine_method_for_expr  —  Function framecode, frameargs, lenv, argtypes = determine_method_for_expr(expr; enter_generated = false) Prepare all the information needed to execute a particular  :call  expression  expr . For example, try  JuliaInterpreter.determine_method_for_expr(:($sum([1,2]))) . See  JuliaInterpreter.prepare_call  for information about the outputs. source"},{"id":305,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_args","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_args","content":" JuliaInterpreter.prepare_args  —  Function frun, allargs = prepare_args(fcall, fargs, kwargs) Prepare the complete argument sequence for a call to  fcall .  fargs = [fcall, args...]  is a list containing both  fcall  (the  #self#  slot in lowered code) and the positional arguments supplied to  fcall .  kwargs  is a list of keyword arguments, supplied either as list of expressions  :(kwname=kwval)  or pairs  :kwname=>kwval . For non-keyword methods,  frun === fcall , but for methods with keywords  frun  will be the keyword-sorter function for  fcall . Example julia> mymethod(x) = 1\nmymethod (generic function with 1 method)\n\njulia> mymethod(x, y; verbose=false) = nothing\nmymethod (generic function with 2 methods)\n\njulia> JuliaInterpreter.prepare_args(mymethod, [mymethod, 15], ())\n(mymethod, Any[mymethod, 15])\n\njulia> JuliaInterpreter.prepare_args(mymethod, [mymethod, 1, 2], [:verbose=>true])\n(var\"#mymethod##kw\"(), Any[var\"#mymethod##kw\"(), (verbose = true,), mymethod, 1, 2]) source"},{"id":306,"pagetitle":"Function reference","title":"JuliaInterpreter.prepare_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.prepare_call","content":" JuliaInterpreter.prepare_call  —  Function framecode, frameargs, lenv, argtypes = prepare_call(f, allargs; enter_generated=false) Prepare all the information needed to execute lowered code for  f  given arguments  allargs .  f  and  allargs  are the outputs of  prepare_args . For  @generated  methods, set  enter_generated=true  if you want to extract the lowered code of the generator itself. On return  framecode  is the  FrameCode  of the method.  frameargs  contains the actual arguments needed for executing this frame (for generators, this will be the types of  allargs );  lenv  is the \"environment\", i.e., the static parameters for  f  given  allargs .  argtypes  is the  Tuple -type for this specific call (equivalent to the signature of the  MethodInstance ). Example julia> mymethod(x::Vector{T}) where T = 1\nmymethod (generic function with 1 method)\n\njulia> framecode, frameargs, lenv, argtypes = JuliaInterpreter.prepare_call(mymethod, [mymethod, [1.0,2.0]]);\n\njulia> framecode\n  1  1  1 ─     return 1\n\njulia> frameargs\n2-element Vector{Any}:\n mymethod (generic function with 1 method)\n [1.0, 2.0]\n\njulia> lenv\nsvec(Float64)\n\njulia> argtypes\nTuple{typeof(mymethod), Vector{Float64}} source"},{"id":307,"pagetitle":"Function reference","title":"JuliaInterpreter.get_call_framecode","ref":"/debug/stable/dev_reference/#JuliaInterpreter.get_call_framecode","content":" JuliaInterpreter.get_call_framecode  —  Function framecode, lenv = get_call_framecode(fargs, parentframe::FrameCode, idx::Int) Return the framecode and environment for a call specified by  fargs = [f, args...]  (see  prepare_args ).  parentframecode  is the caller, and  idx  is the program-counter index. If possible,  framecode  will be looked up from the local method tables of  parentframe . source"},{"id":308,"pagetitle":"Function reference","title":"JuliaInterpreter.optimize!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.optimize!","content":" JuliaInterpreter.optimize!  —  Function optimize!(code::CodeInfo, mod::Module) Perform minor optimizations on the lowered AST in  code  to reduce execution time of the interpreter. Currently it looks up  GlobalRef s (for which it needs  mod  to know the scope in which this will run) and ensures that no statement includes nested  :call  expressions (splitting them out into multiple SSA-form statements if needed). source"},{"id":309,"pagetitle":"Function reference","title":"Frame traversal","ref":"/debug/stable/dev_reference/#Frame-traversal","content":" Frame traversal"},{"id":310,"pagetitle":"Function reference","title":"JuliaInterpreter.root","ref":"/debug/stable/dev_reference/#JuliaInterpreter.root","content":" JuliaInterpreter.root  —  Function rframe = root(frame) Return the initial frame in the call stack. source"},{"id":311,"pagetitle":"Function reference","title":"JuliaInterpreter.leaf","ref":"/debug/stable/dev_reference/#JuliaInterpreter.leaf","content":" JuliaInterpreter.leaf  —  Function lframe = leaf(frame) Return the deepest callee in the call stack. source"},{"id":312,"pagetitle":"Function reference","title":"Frame execution","ref":"/debug/stable/dev_reference/#Frame-execution","content":" Frame execution"},{"id":313,"pagetitle":"Function reference","title":"JuliaInterpreter.Compiled","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Compiled","content":" JuliaInterpreter.Compiled  —  Type Compiled  is a trait indicating that any  :call  expressions should be evaluated using Julia's normal compiled-code evaluation. The alternative is to pass  stack=Frame[] , which will cause all calls to be evaluated via the interpreter. source"},{"id":314,"pagetitle":"Function reference","title":"JuliaInterpreter.step_expr!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.step_expr!","content":" JuliaInterpreter.step_expr!  —  Function pc = step_expr!(recurse, frame, istoplevel=false)\npc = step_expr!(frame, istoplevel=false) Execute the next statement in  frame .  pc  is the new program counter, or  nothing  if execution terminates, or a  BreakpointRef  if execution hits a breakpoint. recurse  controls call evaluation;  recurse = Compiled()  evaluates :call expressions by normal dispatch. The default value  recurse = finish_and_return!  will use recursive interpretation. If you are evaluating  frame  at module scope you should pass  istoplevel=true . source"},{"id":315,"pagetitle":"Function reference","title":"JuliaInterpreter.finish!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish!","content":" JuliaInterpreter.finish!  —  Function pc = finish!(recurse, frame, istoplevel=false)\npc = finish!(frame, istoplevel=false) Run  frame  until execution terminates.  pc  is either  nothing  (if execution terminates when it hits a  return  statement) or a reference to a breakpoint. In the latter case,  leaf(frame)  returns the frame in which it hit the breakpoint. recurse  controls call evaluation;  recurse = Compiled()  evaluates :call expressions by normal dispatch, whereas the default  recurse = finish_and_return!  uses recursive interpretation. source"},{"id":316,"pagetitle":"Function reference","title":"JuliaInterpreter.finish_and_return!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish_and_return!","content":" JuliaInterpreter.finish_and_return!  —  Function ret = finish_and_return!(recurse, frame, istoplevel::Bool=false)\nret = finish_and_return!(frame, istoplevel::Bool=false) Call  JuliaInterpreter.finish!  and pass back the return value  ret . If execution pauses at a breakpoint,  ret  is the reference to the breakpoint. source"},{"id":317,"pagetitle":"Function reference","title":"JuliaInterpreter.finish_stack!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.finish_stack!","content":" JuliaInterpreter.finish_stack!  —  Function ret = finish_stack!(recurse, frame, rootistoplevel=false)\nret = finish_stack!(frame, rootistoplevel=false) Unwind the callees of  frame , finishing each before returning to the caller.  frame  itself is also finished.  rootistoplevel  should be true if the root frame is top-level. ret  is typically the returned value. If execution hits a breakpoint,  ret  will be a reference to the breakpoint. source"},{"id":318,"pagetitle":"Function reference","title":"JuliaInterpreter.get_return","ref":"/debug/stable/dev_reference/#JuliaInterpreter.get_return","content":" JuliaInterpreter.get_return  —  Function ret = get_return(frame) Get the return value of  frame . Throws an error if  frame.pc  does not point to a  return  expression.  frame  must have already been executed so that the return value has been computed (see, e.g.,  JuliaInterpreter.finish! ). source"},{"id":319,"pagetitle":"Function reference","title":"JuliaInterpreter.next_until!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_until!","content":" JuliaInterpreter.next_until!  —  Function pc = next_until!(predicate, recurse, frame, istoplevel=false)\npc = next_until!(predicate, frame, istoplevel=false) Execute the current statement. Then step through statements of  frame  until the next statement satisfies  predicate(frame) .  pc  will be the index of the statement at which evaluation terminates,  nothing  (if the frame reached a  return ), or a  BreakpointRef . source"},{"id":320,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_next_until!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_next_until!","content":" JuliaInterpreter.maybe_next_until!  —  Function pc = maybe_next_until!(predicate, recurse, frame, istoplevel=false)\npc = maybe_next_until!(predicate, frame, istoplevel=false) Like  next_until!  except checks  predicate  before executing the current statment. source"},{"id":321,"pagetitle":"Function reference","title":"JuliaInterpreter.through_methoddef_or_done!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.through_methoddef_or_done!","content":" JuliaInterpreter.through_methoddef_or_done!  —  Function pc = through_methoddef_or_done!(recurse, frame)\npc = through_methoddef_or_done!(frame) Runs  frame  at top level until it either finishes (e.g., hits a  return  statement) or defines a new method. source"},{"id":322,"pagetitle":"Function reference","title":"JuliaInterpreter.evaluate_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.evaluate_call!","content":" JuliaInterpreter.evaluate_call!  —  Function ret = evaluate_call!(Compiled(), frame::Frame, call_expr)\nret = evaluate_call!(recurse,    frame::Frame, call_expr) Evaluate a  :call  expression  call_expr  in the context of  frame . The first causes it to be executed using Julia's normal dispatch (compiled code), whereas the second recurses in via the interpreter.  recurse  has a default value of  JuliaInterpreter.finish_and_return! . source"},{"id":323,"pagetitle":"Function reference","title":"JuliaInterpreter.evaluate_foreigncall","ref":"/debug/stable/dev_reference/#JuliaInterpreter.evaluate_foreigncall","content":" JuliaInterpreter.evaluate_foreigncall  —  Function ret = evaluate_foreigncall(recurse, frame::Frame, call_expr) Evaluate a  :foreigncall  (from a  ccall ) statement  callexpr  in the context of  frame . source"},{"id":324,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_evaluate_builtin","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_evaluate_builtin","content":" JuliaInterpreter.maybe_evaluate_builtin  —  Function ret = maybe_evaluate_builtin(frame, call_expr, expand::Bool) If  call_expr  is to a builtin function, evaluate it, returning the result inside a  Some  wrapper. Otherwise, return  call_expr . If  expand  is true,  Core._apply_iterate  calls will be resolved as a call to the applied function. source"},{"id":325,"pagetitle":"Function reference","title":"JuliaInterpreter.next_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_call!","content":" JuliaInterpreter.next_call!  —  Function pc = next_call!(recurse, frame, istoplevel=false)\npc = next_call!(frame, istoplevel=false) Execute the current statement. Continue stepping through  frame  until the next  :return  or  :call  expression. source"},{"id":326,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_next_call!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_next_call!","content":" JuliaInterpreter.maybe_next_call!  —  Function pc = maybe_next_call!(recurse, frame, istoplevel=false)\npc = maybe_next_call!(frame, istoplevel=false) Return the current program counter of  frame  if it is a  :return  or  :call  expression. Otherwise, step through the statements of  frame  until the next  :return  or  :call  expression. source"},{"id":327,"pagetitle":"Function reference","title":"JuliaInterpreter.next_line!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.next_line!","content":" JuliaInterpreter.next_line!  —  Function pc = next_line!(recurse, frame, istoplevel=false)\npc = next_line!(frame, istoplevel=false) Execute until reaching the first call of the next line of the source code. Upon return,  pc  is either the new program counter,  nothing  if a  return  is reached, or a  BreakpointRef  if it encountered a wrapper call. In the latter case, call  leaf(frame)  to obtain the new execution frame. source"},{"id":328,"pagetitle":"Function reference","title":"JuliaInterpreter.until_line!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.until_line!","content":" JuliaInterpreter.until_line!  —  Function pc = until_line!(recurse, frame, line=nothing istoplevel=false)\npc = until_line!(frame, line=nothing, istoplevel=false) Execute until the current frame reaches a line greater than  line . If  line == nothing  execute until the current frame reaches any line greater than the current line. source"},{"id":329,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_reset_frame!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_reset_frame!","content":" JuliaInterpreter.maybe_reset_frame!  —  Function ret = maybe_reset_frame!(recurse, frame, pc, rootistoplevel) Perform a return to the caller, or descend to the level of a breakpoint.  pc  is the return state from the previous command (e.g.,  next_call!  or similar).  rootistoplevel  should be true if the root frame is top-level. ret  will be  nothing  if we have just completed a top-level frame. Otherwise, cframe, cpc = ret where  cframe  is the frame from which execution should continue and  cpc  is the state of  cframe  (the program counter, a  BreakpointRef , or  nothing ). source"},{"id":330,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_step_through_wrapper!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_step_through_wrapper!","content":" JuliaInterpreter.maybe_step_through_wrapper!  —  Function cframe = maybe_step_through_wrapper!(recurse, frame)\ncframe = maybe_step_through_wrapper!(frame) Return the new frame of execution, potentially stepping through \"wrapper\" methods like those that supply default positional arguments or handle keywords.  cframe  is the leaf frame from which execution should start. source"},{"id":331,"pagetitle":"Function reference","title":"JuliaInterpreter.maybe_step_through_kwprep!","ref":"/debug/stable/dev_reference/#JuliaInterpreter.maybe_step_through_kwprep!","content":" JuliaInterpreter.maybe_step_through_kwprep!  —  Function frame = maybe_step_through_kwprep!(recurse, frame)\nframe = maybe_step_through_kwprep!(frame) If  frame.pc  points to the beginning of preparatory work for calling a keyword-argument function, advance forward until the actual call. source"},{"id":332,"pagetitle":"Function reference","title":"JuliaInterpreter.handle_err","ref":"/debug/stable/dev_reference/#JuliaInterpreter.handle_err","content":" JuliaInterpreter.handle_err  —  Function loc = handle_err(recurse, frame, err) Deal with an error  err  that arose while evaluating  frame . There are one of three behaviors: if  frame  catches the error,  loc  is the program counter at which to resume evaluation of  frame ; if  frame  doesn't catch the error, but  break_on_error[]  is  true ,  loc  is a  BreakpointRef ; otherwise,  err  gets rethrown. source"},{"id":333,"pagetitle":"Function reference","title":"JuliaInterpreter.debug_command","ref":"/debug/stable/dev_reference/#JuliaInterpreter.debug_command","content":" JuliaInterpreter.debug_command  —  Function ret = debug_command(recurse, frame, cmd, rootistoplevel=false; line=nothing)\nret = debug_command(frame, cmd, rootistoplevel=false; line=nothing) Perform one \"debugger\" command. The keyword arguments are not used for all debug commands.  cmd  should be one of: :n : advance to the next line :s : step into the next call :sl  step into the last call on the current line (e.g. steps into  f  if the line is  f(g(h(x))) ). :until : advance the frame to line  line  if given, otherwise advance to the line after the current line :c : continue execution until termination or reaching a breakpoint :finish : finish the current frame and return to the parent or one of the 'advanced' commands :nc : step forward to the next call :se : execute a single statement :si : execute a single statement, stepping in if it's a call :sg : step into the generator of a generated function rootistoplevel  and  ret  are as described for  JuliaInterpreter.maybe_reset_frame! . source"},{"id":334,"pagetitle":"Function reference","title":"Breakpoints","ref":"/debug/stable/dev_reference/#Breakpoints","content":" Breakpoints"},{"id":335,"pagetitle":"Function reference","title":"JuliaInterpreter.@breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@breakpoint","content":" JuliaInterpreter.@breakpoint  —  Macro @breakpoint f(args...) condition=nothing\n@breakpoint f(args...) line condition=nothing Break upon entry, or at the specified line number, in the method called by  f(args...) . Optionally supply a condition expressed in terms of the arguments and internal variables of the method. If  line  is supplied, it must be a literal integer. Example Suppose a method  mysum  is defined as follows, where the numbers to the left are the line number in the file: 12 function mysum(A)\n13     s = zero(eltype(A))\n14     for a in A\n15         s += a\n16     end\n17     return s\n18 end Then @breakpoint mysum(A) 15 s>10 would cause execution of the loop to break whenever  s>10 . source"},{"id":336,"pagetitle":"Function reference","title":"JuliaInterpreter.@bp","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@bp","content":" JuliaInterpreter.@bp  —  Macro @bp Insert a breakpoint at a location in the source code. source"},{"id":337,"pagetitle":"Function reference","title":"JuliaInterpreter.breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.breakpoint","content":" JuliaInterpreter.breakpoint  —  Function breakpoint(f, [sig], [line], [condition]) Add a breakpoint to  f  with the specified argument types  sig .¨ If  sig  is not given, the breakpoint will apply to all methods of  f . If  f  is a method, the breakpoint will only apply to that method. Optionally specify an absolute line number  line  in the source file; the default is to break upon entry at the first line of the body. Without  condition , the breakpoint will be triggered every time it is encountered; the second only if  condition  evaluates to  true .  condition  should be written in terms of the arguments and local variables of  f . Example function radius2(x, y)\n    return x^2 + y^2\nend\n\nbreakpoint(radius2, Tuple{Int,Int}, :(y > x)) source breakpoint(file, line, [condition]) Set a breakpoint in  file  at  line . The argument  file  can be a filename, a partial path or absolute path. For example,  file = foo.jl  will match against all files with the name  foo.jl ,  file = src/foo.jl  will match against all paths containing  src/foo.jl , e.g. both  Foo/src/foo.jl  and  Bar/src/foo.jl . Absolute paths only matches against the file with that exact absolute path. source"},{"id":338,"pagetitle":"Function reference","title":"JuliaInterpreter.enable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.enable","content":" JuliaInterpreter.enable  —  Function enable(bp::AbstractBreakpoint) Enable breakpoint  bp . source enable() Enable all breakpoints. source"},{"id":339,"pagetitle":"Function reference","title":"JuliaInterpreter.disable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.disable","content":" JuliaInterpreter.disable  —  Function disable(bp::AbstractBreakpoint) Disable breakpoint  bp . Disabled breakpoints can be re-enabled with  enable . source disable() Disable all breakpoints. source"},{"id":340,"pagetitle":"Function reference","title":"JuliaInterpreter.remove","ref":"/debug/stable/dev_reference/#JuliaInterpreter.remove","content":" JuliaInterpreter.remove  —  Function remove(bp::AbstractBreakpoint) Remove (delete) breakpoint  bp . Removed breakpoints cannot be re-enabled. source remove() Remove all breakpoints. source"},{"id":341,"pagetitle":"Function reference","title":"JuliaInterpreter.toggle","ref":"/debug/stable/dev_reference/#JuliaInterpreter.toggle","content":" JuliaInterpreter.toggle  —  Function toggle(bp::AbstractBreakpoint) Toggle breakpoint  bp . source"},{"id":342,"pagetitle":"Function reference","title":"JuliaInterpreter.break_on","ref":"/debug/stable/dev_reference/#JuliaInterpreter.break_on","content":" JuliaInterpreter.break_on  —  Function break_on(states...) Turn on automatic breakpoints when any of the conditions described in  states  occurs. The supported states are: :error : trigger a breakpoint any time an uncaught exception is thrown :throw  : trigger a breakpoint any time a throw is executed (even if it will eventually be caught) source"},{"id":343,"pagetitle":"Function reference","title":"JuliaInterpreter.break_off","ref":"/debug/stable/dev_reference/#JuliaInterpreter.break_off","content":" JuliaInterpreter.break_off  —  Function break_off(states...) Turn off automatic breakpoints when any of the conditions described in  states  occurs. See  break_on  for a description of valid states. source"},{"id":344,"pagetitle":"Function reference","title":"JuliaInterpreter.breakpoints","ref":"/debug/stable/dev_reference/#JuliaInterpreter.breakpoints","content":" JuliaInterpreter.breakpoints  —  Function breakpoints()::Vector{AbstractBreakpoint} Return an array with all breakpoints. source"},{"id":345,"pagetitle":"Function reference","title":"JuliaInterpreter.dummy_breakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.dummy_breakpoint","content":" JuliaInterpreter.dummy_breakpoint  —  Function bpref = dummy_breakpoint(recurse, frame::Frame, istoplevel) Return a fake breakpoint.  dummy_breakpoint  can be useful as the  recurse  argument to  evaluate_call!  (or any of the higher-order commands) to ensure that you return immediately after stepping into a call. source"},{"id":346,"pagetitle":"Function reference","title":"Types","ref":"/debug/stable/dev_reference/#Types","content":" Types"},{"id":347,"pagetitle":"Function reference","title":"JuliaInterpreter.Frame","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Frame","content":" JuliaInterpreter.Frame  —  Type Frame  represents the current execution state in a particular call frame. Fields: framecode : the  FrameCode  for this frame. framedata : the  FrameData  for this frame. pc : the program counter (integer index of the next statment to be evaluated) for this frame. caller : the parent caller of this frame, or  nothing . callee : the frame called by this one, or  nothing . The  Base  functions  show_backtrace  and  display_error  are overloaded such that  show_backtrace(io::IO, frame::Frame)  and  display_error(io::IO, er, frame::Frame)  shows a backtrace or error, respectively, in a similar way as to how Base shows them. source"},{"id":348,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameCode","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameCode","content":" JuliaInterpreter.FrameCode  —  Type FrameCode  holds static information about a method or toplevel code. One  FrameCode  can be shared by many calling  Frame s. Important fields: scope : the  Method  or  Module  in which this frame is to be evaluated. src : the  CodeInfo  object storing (optimized) lowered source code. methodtables : a vector, each entry potentially stores a \"local method table\" for the corresponding  :call  expression in  src  (undefined entries correspond to statements that do not contain  :call  expressions). used : a  BitSet  storing the list of SSAValues that get referenced by later statements. source"},{"id":349,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameData","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameData","content":" JuliaInterpreter.FrameData  —  Type FrameData  holds the arguments, local variables, and intermediate execution state in a particular call frame. Important fields: locals : a vector containing the input arguments and named local variables for this frame. The indexing corresponds to the names in the  slotnames  of the src. Use  locals  to extract the current value of local variables. ssavalues : a vector containing the  Static Single Assignment  values produced at the current state of execution. sparams : the static type parameters, e.g., for  f(x::Vector{T}) where T  this would store the value of  T  given the particular input  x . exception_frames : a list of indexes to  catch  blocks for handling exceptions within the current frame. The active handler is the last one on the list. last_exception : the exception  throw n by this frame or one of its callees. source"},{"id":350,"pagetitle":"Function reference","title":"JuliaInterpreter._INACTIVE_EXCEPTION","ref":"/debug/stable/dev_reference/#JuliaInterpreter._INACTIVE_EXCEPTION","content":" JuliaInterpreter._INACTIVE_EXCEPTION  —  Type _INACTIVE_EXCEPTION Represents a case where no exceptions are thrown yet. End users will not see this singleton type, otherwise it usually means there is missing error handling in the interpretation process. source"},{"id":351,"pagetitle":"Function reference","title":"JuliaInterpreter.FrameInstance","ref":"/debug/stable/dev_reference/#JuliaInterpreter.FrameInstance","content":" JuliaInterpreter.FrameInstance  —  Type FrameInstance  represents a method specialized for particular argument types. Fields: framecode : the  FrameCode  for the method. sparam_vals : the static parameter values for the method. source"},{"id":352,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointState","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointState","content":" JuliaInterpreter.BreakpointState  —  Type BreakpointState(isactive=true, condition=JuliaInterpreter.truecondition) BreakpointState  represents a breakpoint at a particular statement in a  FrameCode .  isactive  indicates whether the breakpoint is currently  enable d or  disable d.  condition  is a function that accepts a single  Frame , and  condition(frame)  must return either  true  or  false . Execution will stop at a breakpoint only if  isactive  and  condition(frame)  both evaluate as  true . The default  condition  always returns  true . To create these objects, see  breakpoint . source"},{"id":353,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointRef","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointRef","content":" JuliaInterpreter.BreakpointRef  —  Type BreakpointRef(framecode, stmtidx)\nBreakpointRef(framecode, stmtidx, err) A reference to a breakpoint at a particular statement index  stmtidx  in  framecode . If the break was due to an error, supply that as well. Commands that execute complex control-flow (e.g.,  next_line! ) may also return a  BreakpointRef  to indicate that the execution stack switched frames, even when no breakpoint has been set at the corresponding statement. source"},{"id":354,"pagetitle":"Function reference","title":"JuliaInterpreter.AbstractBreakpoint","ref":"/debug/stable/dev_reference/#JuliaInterpreter.AbstractBreakpoint","content":" JuliaInterpreter.AbstractBreakpoint  —  Type AbstractBreakpoint  is the abstract type that is the supertype for breakpoints. Currently, the concrete breakpoint types  BreakpointSignature  and  BreakpointFileLocation  exist. Common fields shared by the concrete breakpoints: condition::Union{Nothing,Expr,Tuple{Module,Expr}} : the condition when the breakpoint applies .  nothing  means unconditionally, otherwise when the  Expr  (optionally in  Module ). enabled::Ref{Bool} : If the breakpoint is enabled (should not be directly modified, use  enable()  or  disable() ). instances::Vector{BreakpointRef} : All the  BreakpointRef  that the breakpoint has applied to. line::Int  The line of the breakpoint (equal to 0 if unset). See  BreakpointSignature  and  BreakpointFileLocation  for additional fields in the concrete types. source"},{"id":355,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointSignature","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointSignature","content":" JuliaInterpreter.BreakpointSignature  —  Type A  BreakpointSignature  is a breakpoint that is set on methods or functions. Fields: f::Union{Method, Function, Type} : A method or function that the breakpoint should apply to. sig::Union{Nothing, Type} : if  f  is a  Method , always equal to  nothing . Otherwise, contains the method signature  as a tuple type for what methods the breakpoint should apply to. For common fields shared by all breakpoints, see  AbstractBreakpoint . source"},{"id":356,"pagetitle":"Function reference","title":"JuliaInterpreter.BreakpointFileLocation","ref":"/debug/stable/dev_reference/#JuliaInterpreter.BreakpointFileLocation","content":" JuliaInterpreter.BreakpointFileLocation  —  Type A  BreakpointFileLocation  is a breakpoint that is set on a line in a file. Fields: path::String : The literal string that was used to create the breakpoint, e.g.  \"path/file.jl\" . abspath ::String: The absolute path to the file when the breakpoint was created, e.g.  \"/Users/Someone/path/file.jl\" . For common fields shared by all breakpoints, see  AbstractBreakpoint . source"},{"id":357,"pagetitle":"Function reference","title":"Internal storage","ref":"/debug/stable/dev_reference/#Internal-storage","content":" Internal storage"},{"id":358,"pagetitle":"Function reference","title":"JuliaInterpreter.framedict","ref":"/debug/stable/dev_reference/#JuliaInterpreter.framedict","content":" JuliaInterpreter.framedict  —  Constant framedict[method]  returns the  FrameCode  for  method . For  @generated  methods, see  genframedict . source"},{"id":359,"pagetitle":"Function reference","title":"JuliaInterpreter.genframedict","ref":"/debug/stable/dev_reference/#JuliaInterpreter.genframedict","content":" JuliaInterpreter.genframedict  —  Constant genframedict[(method,argtypes)]  returns the  FrameCode  for a  @generated  method  method , for the particular argument types  argtypes . The framecodes stored in  genframedict  are for the code returned by the generator (i.e, what will run when you call the method on particular argument types); for the generator itself, its framecode would be stored in  framedict . source"},{"id":360,"pagetitle":"Function reference","title":"JuliaInterpreter.compiled_methods","ref":"/debug/stable/dev_reference/#JuliaInterpreter.compiled_methods","content":" JuliaInterpreter.compiled_methods  —  Constant meth ∈ compiled_methods  indicates that  meth  should be run using  Compiled  rather than recursed into via the interpreter. source"},{"id":361,"pagetitle":"Function reference","title":"JuliaInterpreter.compiled_modules","ref":"/debug/stable/dev_reference/#JuliaInterpreter.compiled_modules","content":" JuliaInterpreter.compiled_modules  —  Constant mod ∈ compiled_modules  indicates that any method in  mod  should be run using  Compiled  rather than recursed into via the interpreter. source"},{"id":362,"pagetitle":"Function reference","title":"JuliaInterpreter.interpreted_methods","ref":"/debug/stable/dev_reference/#JuliaInterpreter.interpreted_methods","content":" JuliaInterpreter.interpreted_methods  —  Constant meth ∈ interpreted_methods  indicates that  meth  should  not  be run using  Compiled  and recursed into via the interpreter. This takes precedence over  compiled_methods  and  compiled_modules . source"},{"id":363,"pagetitle":"Function reference","title":"Utilities","ref":"/debug/stable/dev_reference/#Utilities","content":" Utilities"},{"id":364,"pagetitle":"Function reference","title":"JuliaInterpreter.eval_code","ref":"/debug/stable/dev_reference/#JuliaInterpreter.eval_code","content":" JuliaInterpreter.eval_code  —  Function eval_code(frame::Frame, code::Union{String, Expr}) Evaluate  code  in the context of  frame , updating any local variables (including type parameters) that are reassigned in  code , however, new local variables cannot be introduced. julia> foo(x, y) = x + y;\n\njulia> frame = JuliaInterpreter.enter_call(foo, 1, 3);\n\njulia> JuliaInterpreter.eval_code(frame, \"x + y\")\n4\n\njulia> JuliaInterpreter.eval_code(frame, \"x = 5\");\n\njulia> JuliaInterpreter.finish_and_return!(frame)\n8 When variables are captured in closures (and thus gets wrapped in a  Core.Box ) they will be automatically unwrapped and rewrapped upon evaluating them: julia> function capture()\n           x = 1\n           f = ()->(x = 2) # x captured in closure and is thus a Core.Box\n           f()\n           x\n       end;\n\njulia> frame = JuliaInterpreter.enter_call(capture);\n\njulia> JuliaInterpreter.step_expr!(frame);\n\njulia> JuliaInterpreter.step_expr!(frame);\n\njulia> JuliaInterpreter.locals(frame)\n2-element Vector{JuliaInterpreter.Variable}:\n #self# = capture\n x = Core.Box(1)\n\njulia> JuliaInterpreter.eval_code(frame, \"x\")\n1\n\njulia> JuliaInterpreter.eval_code(frame, \"x = 2\")\n2\n\njulia> JuliaInterpreter.locals(frame)\n2-element Vector{JuliaInterpreter.Variable}:\n #self# = capture\n x = Core.Box(2) \"Special\" values like SSA values and slots (shown in lowered code as e.g.  %3  and  @_4  respectively) can be evaluated using the syntax  var\"%3\"  and  var\"@_4\"  respectively. source"},{"id":365,"pagetitle":"Function reference","title":"JuliaInterpreter.@lookup","ref":"/debug/stable/dev_reference/#JuliaInterpreter.@lookup","content":" JuliaInterpreter.@lookup  —  Macro rhs = @lookup(frame, node)\nrhs = @lookup(mod, frame, node) This macro looks up previously-computed values referenced as SSAValues, SlotNumbers, GlobalRefs, QuoteNode, sparam or exception reference expression. It will also lookup symbols in  moduleof(frame) ; this can be supplied ahead-of-time via the 3-argument version. If none of the above apply, the value of  node  will be returned. source"},{"id":366,"pagetitle":"Function reference","title":"JuliaInterpreter.is_wrapper_call","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_wrapper_call","content":" JuliaInterpreter.is_wrapper_call  —  Function Determine whether we are calling a function for which the current function is a wrapper (either because of optional arguments or because of keyword arguments). source"},{"id":367,"pagetitle":"Function reference","title":"JuliaInterpreter.is_doc_expr","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_doc_expr","content":" JuliaInterpreter.is_doc_expr  —  Function is_doc_expr(ex) Test whether expression  ex  is a  @doc  expression. source"},{"id":368,"pagetitle":"Function reference","title":"JuliaInterpreter.is_global_ref","ref":"/debug/stable/dev_reference/#JuliaInterpreter.is_global_ref","content":" JuliaInterpreter.is_global_ref  —  Function is_global_ref(g, mod, name) Tests whether  g  is equal to  GlobalRef(mod, name) . source"},{"id":369,"pagetitle":"Function reference","title":"CodeTracking.whereis","ref":"/debug/stable/dev_reference/#CodeTracking.whereis","content":" CodeTracking.whereis  —  Function loc = whereis(frame, pc::Int=frame.pc; macro_caller=false) Return the file and line number for  frame  at  pc .  If this cannot be determined,  loc == nothing . Otherwise  loc == (filepath, line) . By default, any statements expanded from a macro are attributed to the macro definition, but with macro_caller=true  you can obtain the location within the method that issued the macro. source"},{"id":370,"pagetitle":"Function reference","title":"JuliaInterpreter.linenumber","ref":"/debug/stable/dev_reference/#JuliaInterpreter.linenumber","content":" JuliaInterpreter.linenumber  —  Function line = linenumber(framecode, pc) Return the \"static\" line number at statement index  pc . The static line number is the location at the time the method was most recently defined. See  CodeTracking.whereis  for dynamic line information. source"},{"id":371,"pagetitle":"Function reference","title":"JuliaInterpreter.Variable","ref":"/debug/stable/dev_reference/#JuliaInterpreter.Variable","content":" JuliaInterpreter.Variable  —  Type Variable  is a struct representing a variable with an asigned value. By calling the function  locals  on a  Frame  a  Vector  of  Variable 's is returned. Important fields: value::Any : the value of the local variable. name::Symbol : the name of the variable as given in the source code. isparam::Bool : if the variable is a type parameter, for example  T  in  f(x::T) where {T} = x . is_captured_closure::Bool : if the variable has been captured by a closure source"},{"id":372,"pagetitle":"Function reference","title":"JuliaInterpreter.locals","ref":"/debug/stable/dev_reference/#JuliaInterpreter.locals","content":" JuliaInterpreter.locals  —  Function local_variables = locals(frame::Frame)::Vector{Variable} Return the local variables as a vector of  Variable . source"},{"id":373,"pagetitle":"Function reference","title":"JuliaInterpreter.whichtt","ref":"/debug/stable/dev_reference/#JuliaInterpreter.whichtt","content":" JuliaInterpreter.whichtt  —  Function method = whichtt(tt) Like  which  except it operates on the complete tuple-type  tt , and doesn't throw when there is no matching method. source"},{"id":374,"pagetitle":"Function reference","title":"Hooks","ref":"/debug/stable/dev_reference/#Hooks","content":" Hooks"},{"id":375,"pagetitle":"Function reference","title":"JuliaInterpreter.on_breakpoints_updated","ref":"/debug/stable/dev_reference/#JuliaInterpreter.on_breakpoints_updated","content":" JuliaInterpreter.on_breakpoints_updated  —  Function on_breakpoints_updated(f) Register a one-argument function to be called after any update to the set of all breakpoints. This includes their creation, deletion, enabling and disabling. The function  f  should take two inputs: First argument is the function doing to update, this is provided to allow to dispatch on its type. It will be one: ::typeof(breakpoint)  for the creation, ::typeof(remove)  for the deletion. ::typeof(update_states)  for disable/enable/toggleing Second argument is the breakpoint object that was changed. If only desiring to handle some kinds of update,  f  should have fallback methods to do nothing in the general case. Warning This feature is experimental, and may be modified or removed in a minor release. source"},{"id":376,"pagetitle":"Function reference","title":"JuliaInterpreter.firehooks","ref":"/debug/stable/dev_reference/#JuliaInterpreter.firehooks","content":" JuliaInterpreter.firehooks  —  Function firehooks(hooked_fun, bp::AbstractBreakpoint) Trigger all hooks that were registered with  on_breakpoints_updated , passing them the  hooked_fun  and the  bp . This should be called whenever the set of breakpoints is updated.  hooked_fun  is the function doing the update, and  bp  is the relevent breakpoint being updated  after  the update is applied. Warning This feature is experimental, and may be modified or removed in a minor release. source"},{"id":379,"pagetitle":"Internals","title":"Internals","ref":"/debug/stable/internals/#Internals","content":" Internals"},{"id":380,"pagetitle":"Internals","title":"Basic usage","ref":"/debug/stable/internals/#Basic-usage","content":" Basic usage The process of executing code in the interpreter is to prepare a  frame  and then evaluate these statements one-by-one, branching via the  goto  statements as appropriate. Using the  summer  example described in  Lowered representation , let's build a frame: julia> frame = JuliaInterpreter.enter_call(summer, A)\nFrame for summer(A::AbstractArray{T,N} where N) where T in Main at REPL[2]:2\n   1* 2  1 ─       s = (zero)($(Expr(:static_parameter, 1)))\n   2  3  │   %2  = A\n   3  3  │         #temp# = (iterate)(%2)\n⋮\nA = [1, 2, 5]\nT = Int64 This is a  Frame . Only a portion of the  CodeInfo  is shown, a small region surrounding the current statement (marked with  *  or in yellow text). The full  CodeInfo  can be extracted as  code = frame.framecode.src . (It's a slightly modified form of one returned by  @code_lowered , in that it has been processed by  JuliaInterpreter.optimize!  to speed up run-time execution.) frame  has another field,  framedata , that holds values needed for or generated by execution. The input arguments and local variables are in  locals : julia> frame.framedata.locals\n5-element Array{Union{Nothing, Some{Any}},1}:\n Some(summer)\n Some([1, 2, 5])\n nothing\n nothing\n nothing These correspond to the  code.slotnames ; the first is the  #self#  argument and the second is the input array. The remaining local variables (e.g.,  s  and  a ), have not yet been assigned–-we've only built the frame, but we haven't yet begun to execute it. The static parameter,  T , is stored in  frame.framedata.sparams : julia> frame.framedata.sparams\n1-element Array{Any,1}:\n Int64 The  Expr(:static_parameter, 1)  statement refers to this value. The other main storage is for the generated SSA values: julia> frame.framedata.ssavalues\n16-element Array{Any,1}:\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef Since we haven't executed any statements yet, these are all undefined. The other main entity is the so-called  program counter , which just indicates the next statement to be executed: julia> frame.pc\n1 Let's try executing the first statement: julia> JuliaInterpreter.step_expr!(frame)\n2 This indicates that it ran statement 1 and is prepared to run statement 2. (It's worth noting that the first line included a  call  to  zero , so behind the scenes JuliaInterpreter created a new frame for  zero , executed all the statements, and then popped back to  frame .) Since the first statement is an assignment of a local variable, let's check the locals again: julia> frame.framedata.locals\n5-element Array{Union{Nothing, Some{Any}},1}:\n Some(summer)\n Some([1, 2, 5])\n Some(0)\n nothing\n nothing You can see that the entry corresponding to  s  has been initialized. The next statement just retrieves one of the slots (the input argument  A ) and stores it in an SSA value: julia> JuliaInterpreter.step_expr!(frame)\n3\n\njulia> frame.framedata.ssavalues\n16-element Array{Any,1}:\n #undef\n    [1, 2, 5]\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef\n #undef One can easily continue this until execution completes, which is indicated when  step_expr!  returns  nothing . Alternatively, use the higher-level  JuliaInterpreter.finish!(frame)  to step through the entire frame, or  JuliaInterpreter.finish_and_return!(frame)  to also obtain the return value."},{"id":381,"pagetitle":"Internals","title":"More complex expressions","ref":"/debug/stable/internals/#More-complex-expressions","content":" More complex expressions Sometimes you might have a whole sequence of expressions you want to run. In such cases, your first thought should be to construct the  Frame  manually. Here's a demonstration: using Test\n\nex = quote\n    x, y = 1, 2\n    @test x + y == 3\nend\n\nframe = Frame(Main, ex)\nJuliaInterpreter.finish_and_return!(frame)\n\n# output\n\nTest Passed\n  Expression: x + y == 3\n   Evaluated: 3 == 3"},{"id":382,"pagetitle":"Internals","title":"Toplevel code and world age","ref":"/debug/stable/internals/#Toplevel-code-and-world-age","content":" Toplevel code and world age Code that defines new  struct s, new methods, or new modules is a bit more complicated and requires special handling. In such cases, calling  finish_and_return!  on a frame that defines these new objects and then calls them can trigger a  world age error , in which the method is considered to be too new to be run by the currently compiled code. While one can resolve this by using  Base.invokelatest , we'd have to use that strategy throughout the entire package.  This would cause a major reduction in performance. To resolve this issue without leading to performance problems, care is required to return to \"top level\" after defining such objects. This leads to altered syntax for executing such expressions. Here's a demonstration of the problem: ex = :(map(x->x^2, [1, 2, 3]))\nframe = Frame(Main, ex)\njulia> JuliaInterpreter.finish_and_return!(frame)\nERROR: this frame needs to be run a top level The reason for this error becomes clearer if we examine  frame  or look directly at the lowered code: julia> Meta.lower(Main, ex)\n:($(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─      $(Expr(:thunk, CodeInfo(\n    @ none within `top-level scope`\n1 ─      global var\"#3#4\"\n│        const var\"#3#4\"\n│   %3 = Core._structtype(Main, Symbol(\"#3#4\"), Core.svec(), Core.svec(), Core.svec(), false, 0)\n│        var\"#3#4\" = %3\n│        Core._setsuper!(var\"#3#4\", Core.Function)\n│        Core._typebody!(var\"#3#4\", Core.svec())\n└──      return nothing\n)))\n│   %2 = Core.svec(var\"#3#4\", Core.Any)\n│   %3 = Core.svec()\n│   %4 = Core.svec(%2, %3, $(QuoteNode(:(#= REPL[18]:1 =#))))\n│        $(Expr(:method, false, :(%4), CodeInfo(\n    @ REPL[18]:1 within `none`\n1 ─ %1 = Core.apply_type(Base.Val, 2)\n│   %2 = (%1)()\n│   %3 = Base.literal_pow(^, x, %2)\n└──      return %3\n)))\n│        #3 = %new(var\"#3#4\")\n│   %7 = #3\n│   %8 = Base.vect(1, 2, 3)\n│   %9 = map(%7, %8)\n└──      return %9\n)))) All of the code before the  %7  line is devoted to defining the anonymous function  x->x^2 : it creates a new \"anonymous type\" (here written as  var\"#3#4\" ), and then defines a \"call function\" for this type, equivalent to  (var\"#3#4\")(x) = x^2 . In some cases one can fix this simply by indicating that we want to run this frame at top level: julia> JuliaInterpreter.finish_and_return!(frame, true)\n3-element Array{Int64,1}:\n 1\n 4\n 9 In other cases, such as nested calls of new methods, you may need to allow the world age to update between evaluations. In such cases you want to use  ExprSplitter : for (mod, e) in ExprSplitter(Main, ex)\n    frame = Frame(mod, e)\n    while true\n        JuliaInterpreter.through_methoddef_or_done!(frame) === nothing && break\n    end\n    JuliaInterpreter.get_return(frame)\nend This splits the expression into a sequence of frames (here just one, but more complex blocks may be split up into many). Then, each frame is executed until it finishes defining a new method, then returns to top level. The return to top level causes an update in the world age. If the frame hasn't been finished yet (if the return value wasn't  nothing ), this continues executing where it left off. (Incidentally,  JuliaInterpreter.enter_call(map, x->x^2, [1, 2, 3])  works fine on its own, because the anonymous function is defined by the caller–-you'll see that the created frame is very simple.)"}]